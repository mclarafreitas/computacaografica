<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<meta name="author" content="Maria Clara Moura de Freitas (20230093652) &lt;maria.clarafreitas@hotmail.com&gt;">
<title>Lista de Exercícios - Computação Gráfica (2025.1)</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article">
<div id="header">
<h1>Lista de Exercícios - Computação Gráfica (2025.1)</h1>
<div class="details">
<span id="author" class="author">Maria Clara Moura de Freitas (20230093652) &lt;maria.clarafreitas@hotmail.com&gt;</span><br>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_capítulo_2">Capítulo 2</a>
<ul class="sectlevel2">
<li><a href="#_exercício_1">Exercício 1</a></li>
<li><a href="#_exercício_2">Exercício 2</a></li>
</ul>
</li>
<li><a href="#_capítulo_3">Capítulo 3</a>
<ul class="sectlevel2">
<li><a href="#_exercício_1_2">Exercício 1</a></li>
<li><a href="#_exercício_2_2">Exercício 2</a></li>
<li><a href="#_exercício_3">Exercício 3</a></li>
</ul>
</li>
<li><a href="#_capítulo_4">Capítulo 4</a>
<ul class="sectlevel2">
<li><a href="#_exercício_1_3">Exercício 1</a></li>
<li><a href="#_exercício_2_3">Exercício 2</a></li>
<li><a href="#_exercício_3_2">Exercício 3</a></li>
</ul>
</li>
<li><a href="#_capítulo_5">Capítulo 5</a>
<ul class="sectlevel2">
<li><a href="#_exercício_1_4">Exercício 1</a></li>
<li><a href="#_exercício_2_4">Exercício 2</a></li>
</ul>
</li>
<li><a href="#_capítulo_6">Capítulo 6</a>
<ul class="sectlevel2">
<li><a href="#_exercício_1_5">Exercício 1</a></li>
<li><a href="#_exercício_2_5">Exercício 2</a></li>
</ul>
</li>
<li><a href="#_capítulo_7">Capítulo 7</a>
<ul class="sectlevel2">
<li><a href="#_exercício_1_6">Exercício 1</a></li>
</ul>
</li>
<li><a href="#_capítulo_8">Capítulo 8</a>
<ul class="sectlevel2">
<li><a href="#_exercício_1_7">Exercício 1</a></li>
</ul>
</li>
<li><a href="#_capítulo_9">Capítulo 9</a>
<ul class="sectlevel2">
<li><a href="#_exercício_1_8">Exercício 1</a></li>
</ul>
</li>
<li><a href="#_capítulo_10">Capítulo 10</a>
<ul class="sectlevel2">
<li><a href="#_exercício_1_9">Exercício 1</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Esta página documenta os exercícios desenvolvidos para a disciplina de Computação Gráfica, ofertada pela UFRN no semestre 2025.1. Os programas foram implementados utilizando a API OpenGL, e sua execução pode requerer a instalação de dependências adicionais, especialmente em sistemas que não possuem bibliotecas gráficas pré-configuradas.
Alguns exercícios utilizam extensões específicas da OpenGL, que também devem ser previamente instaladas para garantir o funcionamento correto dos programas. Para facilitar a compilação e execução dos códigos, foi utilizado o Makefile fornecido pelo professor, com adaptações para sistemas macOS, bem como os arquivos de headers necessários.</p>
</div>
<div class="paragraph">
<p>Todos os códigos estão disponiveis em meu <a href="https://github.com/mclarafreitas/computacaografica" class="external" target="_blank" rel="noopener">Github</a> e todos os exercicios estão localizados na página pessoal do professor <a href="https://agostinhobritojr.github.io/tutorial/opengl/index.html" class="external" target="_blank" rel="noopener">Agostinho Brito</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_capítulo_2">Capítulo 2</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Como etapa inicial, realizamos testes com o código <strong>teste-make.c</strong>, disponibilizado pelo professor, com o objetivo de configurar e validar o ambiente de execução necessário para o desenvolvimento das atividades da disciplina. Esse teste inicial garante que as bibliotecas, extensões e o Makefile estejam funcionando corretamente no sistema operacional utilizado.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[teste-make.c]
/* programa teste-make.c */

#include &lt;GLUT/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void display(void);
void timer(int);
void keyboard(unsigned char key, int x, int y);

/* cores do quadrado */
GLfloat r=1.0, g=0.5, b=0.0;

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize (256, 256);
  glutInitWindowPosition (100, 100);
  glutCreateWindow (argv[0]);
  // inicia um temporizador. após 33ms ativa a funcao timer
  glutTimerFunc(33, timer, 1);
  glClearColor(1.0, 1.0, 1.0, 0.0);
  glShadeModel (GL_FLAT);
  glOrtho (0, 1, 0, 1, -1 ,1);
  glutDisplayFunc(display);
  glutMainLoop();
  return 0;
}

void timer(int value){
  r=r+0.01;
  g=g+0.01;
  b=b+0.01;
  if(r&gt;1) r=0;
  if(g&gt;1) g=0;
  if(b&gt;1) b=0;
  glutPostRedisplay();
  glutTimerFunc(33, timer, 1);
}

void display(void){
  int i;
  glClear(GL_COLOR_BUFFER_BIT);
  glColor3f (r, g, b);
  glBegin(GL_POLYGON);
  glVertex2f(0.25,0.25);
  glVertex2f(0.75,0.25);
  glVertex2f(0.75,0.75);
  glVertex2f(0.25,0.75);
  glEnd();
  glFlush();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Além disso, um arquivo <strong>Makefile</strong> foi fornecido para automatizar o processo de compilação e tornar a execução dos programas mais ágil. Esse arquivo foi adaptado para garantir compatibilidade com o sistema macOS, permitindo a compilação dos exercícios de forma padronizada e eficiente.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[Makefile]
# Makefile portátil para programas OpenGL com GLUT em C e C++
# Uso: make nome-do-arquivo (sem extensão)

# Detecta o sistema operacional
UNAME_S := $(shell uname -s)

# Compiladores padrão
CC = gcc
CXX = g++
CFLAGS = -O2
CXXFLAGS = -O2

# Configurações específicas por sistema
ifeq ($(UNAME_S), Darwin)
    # macOS usa frameworks
    GL_LIBS = -framework GLUT -framework OpenGL
else
    # Linux usa bibliotecas tradicionais
    INCDIR = /usr/include
    LIBDIR = /usr/lib
    XLIBS = -L/usr/X11/lib -L/usr/X11R6/lib -lX11
    GL_LIBS = -L$(LIBDIR) -lglut -lGLU -lGL -lm -lpng $(XLIBS)
endif

# Suportes de sufixo
.SUFFIXES: .c .cpp

# Regras de compilação
.c:
	$(CC) $(CFLAGS) $&lt; -o $@ $(GL_LIBS)

.cpp:
	$(CXX) $(CXXFLAGS) $&lt; -o $@ $(GL_LIBS)

# Limpeza
clean:
	rm -f *.o *~ a.out</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_exercício_1">Exercício 1</h3>
<div class="paragraph">
<p>Com o ambiente de desenvolvimento devidamente configurado, iniciamos a implementação dos exercícios propostos. O primeiro deles consiste na criação do programa <strong>quadrados4.c</strong>, desenvolvido com base no exemplo <strong>teste-make.c</strong>.</p>
</div>
<div class="paragraph">
<p>O objetivo do exercício é exibir uma janela gráfica de 256x256 pixels, com fundo branco, contendo quatro quadrados de cores distintas, posicionados nas quatro regiões da janela: superior esquerda, superior direita, inferior esquerda e inferior direita. A atividade tem como foco a prática de posicionamento e preenchimento de primitivas gráficas utilizando a biblioteca OpenGL.</p>
</div>
<div class="paragraph">
<p>O programa foi implementado com o uso da biblioteca OpenGL em conjunto com GLUT, responsável pela criação e controle da janela gráfica. A área de visualização foi configurada com a função glOrtho, normalizando o sistema de coordenadas entre 0 e 1, o que facilita o posicionamento relativo dos elementos gráficos. Na função display(), são desenhados quatro quadrados coloridos — vermelho, verde, azul e amarelo — utilizando a função glBegin(GL_POLYGON) para definir os vértices de cada forma. As cores são atribuídas com a função glColor3f, e as posições foram escolhidas de forma a distribuir os quadrados nos quatro cantos da janela. A chamada final a glFlush() garante que todos os comandos de desenho sejam executados e que o conteúdo seja devidamente exibido na tela.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[quadrados4.c]
#include &lt;GLUT/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void display(void);

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize(256, 256);
  glutInitWindowPosition(100, 100);
  glutCreateWindow("Quadrados 4");
  glClearColor(1.0, 1.0, 1.0, 0.0);
  glShadeModel(GL_FLAT);
  glOrtho(0.0, 1.0, 0.0, 1.0, -1.0, 1.0);
  glutDisplayFunc(display);
  glutMainLoop();
  return 0;
}

void display(void){
  glClear(GL_COLOR_BUFFER_BIT);

  // Inferior esquerdo - vermelho
  glColor3f(1.0, 0.0, 0.0);
  glBegin(GL_POLYGON);
  glVertex2f(0.0, 0.0);
  glVertex2f(0.5, 0.0);
  glVertex2f(0.5, 0.5);
  glVertex2f(0.0, 0.5);
  glEnd();

  // Inferior direito - verde
  glColor3f(0.0, 1.0, 0.0);
  glBegin(GL_POLYGON);
  glVertex2f(0.5, 0.0);
  glVertex2f(1.0, 0.0);
  glVertex2f(1.0, 0.5);
  glVertex2f(0.5, 0.5);
  glEnd();

  // Superior esquerdo - azul
  glColor3f(0.0, 0.0, 1.0);
  glBegin(GL_POLYGON);
  glVertex2f(0.0, 0.5);
  glVertex2f(0.5, 0.5);
  glVertex2f(0.5, 1.0);
  glVertex2f(0.0, 1.0);
  glEnd();

  // Superior direito - amarelo
  glColor3f(1.0, 1.0, 0.0);
  glBegin(GL_POLYGON);
  glVertex2f(0.5, 0.5);
  glVertex2f(1.0, 0.5);
  glVertex2f(1.0, 1.0);
  glVertex2f(0.5, 1.0);
  glEnd();

  glFlush();
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="1.png" alt="quadrados4.c">
</div>
<div class="title">Figure 1. Saída do programa quadrado4.c</div>
</div>
</div>
<div class="sect2">
<h3 id="_exercício_2">Exercício 2</h3>
<div class="paragraph">
<p>É pedido para que façamos outro programa com esse mesmo exemplo. A atividade propõe a criação do programa quadradoscolor.c, com base no exemplo teste-make.c. O objetivo é desenhar um quadrado central em uma janela de 256x256 pixels com fundo branco, onde cada vértice possua uma cor diferente. Essas cores devem ser calculadas a partir do modelo de cor HSI (Hue, Saturation, Intensity). O valor de Hue (H) de cada vértice deve variar com o tempo, criando uma animação de transição de cores. Para permitir a visualização do efeito de degradê, é necessário comentar a linha glShadeModel(GL_FLAT), habilitando assim a interpolação de cores entre os vértices com GL_SMOOTH.</p>
</div>
<div class="paragraph">
<p>O programa utiliza a biblioteca OpenGL com GLUT para criar a janela gráfica e desenhar o quadrado. A cor de fundo é definida como branca com glClearColor. O espaço é normalizado com glOrtho para trabalhar com coordenadas entre 0 e 1.
A função display() é responsável por desenhar o quadrado. Para isso, cada vértice recebe uma cor calculada pela função hsiToRgb(), que converte valores HSI em RGB. O valor de H varia entre 0 e 1 e é atualizado a cada ciclo de tempo pela função timer(), que gera a animação contínua ao solicitar o redesenho da tela com glutPostRedisplay().
Por fim, o uso de glShadeModel(GL_SMOOTH) permite que o OpenGL interpole as cores entre os vértices, criando um efeito visual suave e colorido no quadrado conforme os valores de Hue mudam com o tempo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[quadradoscolor.c]
#include &lt;GLUT/glut.h&gt;  // Para macOS
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

#define PI 3.14159265

// HSI de cada vértice (apenas H muda com o tempo)
float H[4] = {0.0, 0.25, 0.5, 0.75}; // valores iniciais de H (entre 0 e 1)
float S = 1.0;  // saturação fixa
float I = 1.0;  // intensidade fixa

// Função para converter HSI para RGB
void hsiToRgb(float h, float s, float i, float *r, float *g, float *b) {
    float r_, g_, b_;

    h = fmod(h, 1.0);         // mantém H no intervalo [0, 1]
    h *= 360;                 // converte para graus

    if (h &lt; 120) {
        float rad = h * PI / 180.0;
        b_ = i * (1 - s);
        r_ = i * (1 + (s * cos(rad)) / cos(PI / 3 - rad));
        g_ = 3 * i - (r_ + b_);
    } else if (h &lt; 240) {
        h -= 120;
        float rad = h * PI / 180.0;
        r_ = i * (1 - s);
        g_ = i * (1 + (s * cos(rad)) / cos(PI / 3 - rad));
        b_ = 3 * i - (r_ + g_);
    } else {
        h -= 240;
        float rad = h * PI / 180.0;
        g_ = i * (1 - s);
        b_ = i * (1 + (s * cos(rad)) / cos(PI / 3 - rad));
        r_ = 3 * i - (g_ + b_);
    }

    *r = fmin(fmax(r_, 0), 1);
    *g = fmin(fmax(g_, 0), 1);
    *b = fmin(fmax(b_, 0), 1);
}

void display(void) {
    glClear(GL_COLOR_BUFFER_BIT);

    // Calcular RGB para cada vértice
    float rgb[4][3];
    for (int i = 0; i &lt; 4; i++) {
        hsiToRgb(H[i], S, I, &amp;rgb[i][0], &amp;rgb[i][1], &amp;rgb[i][2]);
    }

    glBegin(GL_POLYGON);
    glColor3f(rgb[0][0], rgb[0][1], rgb[0][2]); glVertex2f(0.25, 0.25);
    glColor3f(rgb[1][0], rgb[1][1], rgb[1][2]); glVertex2f(0.75, 0.25);
    glColor3f(rgb[2][0], rgb[2][1], rgb[2][2]); glVertex2f(0.75, 0.75);
    glColor3f(rgb[3][0], rgb[3][1], rgb[3][2]); glVertex2f(0.25, 0.75);
    glEnd();

    glFlush();
}

// Timer para animar a rotação do matiz (H) dos vértices
void timer(int value) {
    for (int i = 0; i &lt; 4; i++) {
        H[i] += 0.01;
        if (H[i] &gt; 1.0) H[i] -= 1.0;
    }
    glutPostRedisplay();
    glutTimerFunc(33, timer, 1);
}

int main(int argc, char** argv){
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(256, 256);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Quadrado Colorido com HSI");

    glClearColor(1.0, 1.0, 1.0, 0.0);  // fundo branco

    //glShadeModel(GL_FLAT);  // Comentado para ativar interpolação de cores
    glShadeModel(GL_SMOOTH); // interpolação suave (degradê)

    glOrtho(0.0, 1.0, 0.0, 1.0, -1.0, 1.0);

    glutDisplayFunc(display);
    glutTimerFunc(33, timer, 1);
    glutMainLoop();
    return 0;
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="2.2.gif" alt="quadradoscolor.c">
</div>
<div class="title">Figure 2. Saída do programa quadradoscolor.c</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_capítulo_3">Capítulo 3</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A próxima atividade tem como objetivo introduzir e reforçar a compreensão de recursos fundamentais da biblioteca OpenGL e da GLUT, especialmente no que diz respeito à renderização básica de linhas e pontos na tela.</p>
</div>
<div class="sect2">
<h3 id="_exercício_1_2">Exercício 1</h3>
<div class="paragraph">
<p>O programa <strong>quadrado.c</strong> foi desenvolvido com base no exemplo <strong>linha.c</strong> e tem como objetivo desenhar um quadrado vermelho em uma janela gráfica de 256x256 pixels com fundo branco. O quadrado é definido pelos vértices superiores e inferiores nas coordenadas (30, 226) e (226, 30), respectivamente.</p>
</div>
<div class="paragraph">
<p>Ao ser executado, o programa inicializa o sistema de coordenadas com glOrtho() e configura a cor de fundo com glClearColor(). O quadrado é desenhado com a função glBegin(GL_POLYGON), utilizando coordenadas no espaço 2D. O comportamento interativo é implementado na função keyboard(): Quando a tecla ‘a’ é pressionada, a cor do quadrado muda para azul e ao pressionar a tecla ‘v’, o quadrado retorna à cor vermelha.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[quadrado.c]
#include &lt;GLUT/glut.h&gt;
#include &lt;stdlib.h&gt;

float red = 1.0, green = 0.0, blue = 0.0; // Cor inicial: vermelho

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
  glutInitWindowSize(256, 256);
  glutInitWindowPosition(100, 100);
  glutCreateWindow("Quadrado com Mudança de Cor");
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}

void init(void){
  glClearColor(1.0, 1.0, 1.0, 1.0); // fundo branco
  glOrtho(0, 256, 0, 256, -1, 1);   // define sistema de coordenadas
}

void display(void){
  glClear(GL_COLOR_BUFFER_BIT);

  glColor3f(red, green, blue); // usa a cor atual

  glBegin(GL_POLYGON);
    glVertex2i(30, 226);  // canto superior esquerdo
    glVertex2i(226, 226); // canto superior direito
    glVertex2i(226, 30);  // canto inferior direito
    glVertex2i(30, 30);   // canto inferior esquerdo
  glEnd();

  glFlush();
}

void keyboard(unsigned char key, int x, int y){
  switch (key) {
    case 'a': // muda para azul
      red = 0.0; green = 0.0; blue = 1.0;
      glutPostRedisplay();
      break;

    case 'v': // volta para vermelho
      red = 1.0; green = 0.0; blue = 0.0;
      glutPostRedisplay();
      break;

    case 27: // tecla ESC
      exit(0);
      break;
  }
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="3.1.gif" alt="Saída do exercício 3.1">
</div>
<div class="title">Figure 3. Exercício 3.1</div>
</div>
</div>
<div class="sect2">
<h3 id="_exercício_2_2">Exercício 2</h3>
<div class="paragraph">
<p>O programa <strong>bresenhamlinhas.c</strong> implementa o algoritmo de Bresenham para o traçado eficiente de linhas utilizando pontos discretos. A proposta da atividade é desenhar uma reta verde do ponto (40, 200) até o ponto (200, 10), usando GL_POINTS como parâmetro da função glBegin(), o que indica que cada ponto da linha será desenhado individualmente.</p>
</div>
<div class="paragraph">
<p>A janela gráfica é configurada com dimensões 256x256 pixels e fundo branco. O sistema de coordenadas é definido com glOrtho() para facilitar o mapeamento direto de coordenadas 2D.
A lógica de desenho está na função bresenhamLine(), que implementa o algoritmo de Bresenham generalizado, ou seja, funciona para todas as direções de reta, inclusive com inclinação negativa. O algoritmo calcula o erro incremental entre os pixels a serem desenhados para decidir o ponto mais próximo da linha ideal a cada iteração, garantindo um traçado eficiente sem o uso de operações de ponto flutuante.
A linha é desenhada com glBegin(GL_POINTS) e glVertex2i(x, y), que plota ponto a ponto ao longo do caminho entre os dois vértices especificados. A cor verde é definida com glColor3f(0.0, 1.0, 0.0) antes da chamada à função de traçado.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[bresenhamlinhas.c]

#include &lt;GLUT/glut.h&gt; // Para macOS. No Linux, use &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;

// Protótipos
void init(void);
void display(void);
void bresenhamLine(int x0, int y0, int x1, int y1);

// Função principal
int main(int argc, char** argv) {
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(256, 256);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Linha com Bresenham");
    init();
    glutDisplayFunc(display);
    glutMainLoop();
    return 0;
}

// Inicialização do OpenGL
void init(void) {
    glClearColor(1.0, 1.0, 1.0, 1.0); // Fundo branco
    glOrtho(0, 256, 0, 256, -1, 1);   // Coordenadas da janela
}

// Função de desenho
void display(void) {
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(0.0, 1.0, 0.0); // Cor verde

    // Desenha usando Bresenham
    bresenhamLine(40, 200, 200, 10);

    glFlush();
}

// Algoritmo de Bresenham para todas direções (adaptado)
void bresenhamLine(int x0, int y0, int x1, int y1) {
    int dx = abs(x1 - x0);
    int dy = abs(y1 - y0);

    int sx = (x0 &lt; x1) ? 1 : -1;
    int sy = (y0 &lt; y1) ? 1 : -1;

    int err = dx - dy;

    glBegin(GL_POINTS);
    while (1) {
        glVertex2i(x0, y0);

        if (x0 == x1 &amp;&amp; y0 == y1)
            break;

        int e2 = 2 * err;
        if (e2 &gt; -dy) {
            err -= dy;
            x0 += sx;
        }
        if (e2 &lt; dx) {
            err += dx;
            y0 += sy;
        }
    }
    glEnd();
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="3.2.png" alt="Saída do exercício 3.2">
</div>
<div class="title">Figure 4. Exercício 3.2</div>
</div>
</div>
<div class="sect2">
<h3 id="_exercício_3">Exercício 3</h3>
<div class="paragraph">
<p>O programa <strong>bresenhamcirculo.c</strong> implementa o algoritmo de Bresenham para traçado de circunferências (também conhecido como Midpoint Circle Algorithm), utilizando a primitiva GL_POINTS da OpenGL para desenhar ponto a ponto a circunferência. A atividade solicitava o desenho de uma circunferência azul com raio 50, centrada no ponto (128, 128), o que é feito pela chamada bresenhamCircle(128, 128, 50).</p>
</div>
<div class="paragraph">
<p>A janela gráfica tem dimensões 256x256 pixels, com fundo branco e sistema de coordenadas ortogonais definido por glOrtho(). O algoritmo inicia com o ponto mais à direita do círculo (x = 0, y = r) e, a cada iteração, decide o próximo ponto com base em um valor de decisão d, evitando o uso de operações com ponto flutuante. Devido à simetria da circunferência, para cada ponto calculado no primeiro octante, os demais sete pontos simétricos são desenhados pela função plotCirclePoints().</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[bresenhamcirculo.c]

#include &lt;GLUT/glut.h&gt;
#include &lt;stdlib.h&gt;

// Protótipos
void init(void);
void display(void);
void bresenhamCircle(int xc, int yc, int r);
void plotCirclePoints(int xc, int yc, int x, int y);

// Função principal
int main(int argc, char** argv) {
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(256, 256);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Circunferência com Bresenham");
    init();
    glutDisplayFunc(display);
    glutMainLoop();
    return 0;
}

// Inicialização
void init(void) {
    glClearColor(1.0, 1.0, 1.0, 1.0); // Fundo branco
    glOrtho(0, 256, 0, 256, -1, 1);   // Coordenadas da janela
}

// Função de desenho
void display(void) {
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(0.0, 0.0, 1.0); // Cor azul

    bresenhamCircle(128, 128, 50); // Circunferência centrada em (128,128) com raio 50

    glFlush();
}

// Algoritmo de Bresenham para circunferência (Midpoint Circle Algorithm)
void bresenhamCircle(int xc, int yc, int r) {
    int x = 0;
    int y = r;
    int d = 1 - r;

    glBegin(GL_POINTS);
    plotCirclePoints(xc, yc, x, y);
    while (x &lt; y) {
        x++;
        if (d &lt; 0) {
            d += 2 * x + 1;
        } else {
            y--;
            d += 2 * (x - y) + 1;
        }
        plotCirclePoints(xc, yc, x, y);
    }
    glEnd();
}

// Plota os 8 pontos simétricos da circunferência
void plotCirclePoints(int xc, int yc, int x, int y) {
    glVertex2i(xc + x, yc + y);
    glVertex2i(xc - x, yc + y);
    glVertex2i(xc + x, yc - y);
    glVertex2i(xc - x, yc - y);
    glVertex2i(xc + y, yc + x);
    glVertex2i(xc - y, yc + x);
    glVertex2i(xc + y, yc - x);
    glVertex2i(xc - y, yc - x);
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="3.3.png" alt="Saída do exercício 3.3">
</div>
<div class="title">Figure 5. Exercício 3.3</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_capítulo_4">Capítulo 4</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo tem como objetivo apresentar funções básicas do OpenGL relacionadas ao preenchimento de regiões.</p>
</div>
<div class="sect2">
<h3 id="_exercício_1_3">Exercício 1</h3>
<div class="paragraph">
<p>O programa <strong>selecao.c</strong> foi desenvolvido com base no exemplo <strong>preenchimento.c</strong> e tem como objetivo desenhar quatro polígonos retangulares com as mesmas coordenadas do programa de referência, exibidos em uma janela de 256x256 pixels com fundo branco. Todos os polígonos são inicialmente preenchidos com cor amarela e possuem bordas pretas.</p>
</div>
<div class="paragraph">
<p>A lógica de desenho é baseada em uma estrutura Polygon, que armazena as coordenadas, a cor de preenchimento e a cor da borda de cada polígono. O programa possui interatividade com o mouse e com o teclado:</p>
</div>
<div class="ulist">
<div class="title">O programa possui interatividade com o mouse e com o teclado:</div>
<ul>
<li>
<p>Clique com o botão esquerdo do mouse: altera a cor do polígono clicado.</p>
</li>
<li>
<p>Se o modo atual for de preenchimento (fill), muda a cor de preenchimento.</p>
</li>
<li>
<p>Se o modo atual for de borda (border), muda a cor da borda.</p>
</li>
<li>
<p>Tecla b: muda o modo para edição de bordas.</p>
</li>
<li>
<p>Tecla f: muda o modo para edição de preenchimento.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A função mouse() detecta a posição do clique e determina se ele ocorreu dentro de um dos polígonos, fazendo o ajuste necessário no eixo Y (já que a origem das coordenadas da janela do GLUT é no canto superior esquerdo, enquanto a do OpenGL é no inferior esquerdo). O uso da função randomColor() permite gerar cores aleatórias tanto para o preenchimento quanto para as bordas. A atualização visual é feita com glutPostRedisplay().</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[selecao.c]

#include &lt;GLUT/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

typedef struct {
    int x1, y1, x2, y2;
    GLfloat fillColor[3];
    GLfloat borderColor[3];
} Polygon;

Polygon polys[4];
bool changeFill = true;

void randomColor(GLfloat *color) {
    color[0] = (GLfloat)rand() / (RAND_MAX + 1.0);
    color[1] = (GLfloat)rand() / (RAND_MAX + 1.0);
    color[2] = (GLfloat)rand() / (RAND_MAX + 1.0);
}

void init(void) {
    glClearColor(1.0, 1.0, 1.0, 1.0);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0, 256, 0, 256);

    // Inicializa polígonos com amarelo e bordas pretas
    int coords[4][4] = {
        {30, 143, 113, 226},   // superior esquerdo
        {143, 143, 226, 226},  // superior direito
        {30, 30, 113, 113},    // inferior esquerdo
        {143, 30, 226, 113}    // inferior direito
    };

    for (int i = 0; i &lt; 4; i++) {
        polys[i].x1 = coords[i][0];
        polys[i].y1 = coords[i][1];
        polys[i].x2 = coords[i][2];
        polys[i].y2 = coords[i][3];
        polys[i].fillColor[0] = 1.0;
        polys[i].fillColor[1] = 1.0;
        polys[i].fillColor[2] = 0.0;
        polys[i].borderColor[0] = 0.0;
        polys[i].borderColor[1] = 0.0;
        polys[i].borderColor[2] = 0.0;
    }
}

void drawPolygon(Polygon p) {
    glColor3fv(p.fillColor);
    glBegin(GL_POLYGON);
    glVertex2i(p.x1, p.y1);
    glVertex2i(p.x2, p.y1);
    glVertex2i(p.x2, p.y2);
    glVertex2i(p.x1, p.y2);
    glEnd();

    glColor3fv(p.borderColor);
    glBegin(GL_LINE_LOOP);
    glVertex2i(p.x1, p.y1);
    glVertex2i(p.x2, p.y1);
    glVertex2i(p.x2, p.y2);
    glVertex2i(p.x1, p.y2);
    glEnd();
}

void display(void) {
    glClear(GL_COLOR_BUFFER_BIT);
    for (int i = 0; i &lt; 4; i++) {
        drawPolygon(polys[i]);
    }
    glFlush();
}

void keyboard(unsigned char key, int x, int y) {
    switch (key) {
        case 'f':
        case 'F':
            changeFill = true;
            break;
        case 'b':
        case 'B':
            changeFill = false;
            break;
        case 27: // ESC
            exit(0);
            break;
    }
}

void mouse(int button, int state, int x, int y) {
    if (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_DOWN) {
        int yOpenGL = 256 - y; // Inverter eixo Y
        for (int i = 0; i &lt; 4; i++) {
            if (x &gt;= polys[i].x1 &amp;&amp; x &lt;= polys[i].x2 &amp;&amp;
                yOpenGL &gt;= polys[i].y1 &amp;&amp; yOpenGL &lt;= polys[i].y2) {

                if (changeFill) {
                    randomColor(polys[i].fillColor);
                } else {
                    randomColor(polys[i].borderColor);
                }
                glutPostRedisplay();
                break;
            }
        }
    }
}

int main(int argc, char **argv) {
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(256, 256);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Seleção de polígonos");
    init();
    glutDisplayFunc(display);
    glutKeyboardFunc(keyboard);
    glutMouseFunc(mouse);
    glutMainLoop();
    return 0;
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="4.1.gif" alt="Saída do exercício 4.1">
</div>
<div class="title">Figure 6. Exercício 4.1</div>
</div>
</div>
<div class="sect2">
<h3 id="_exercício_2_3">Exercício 2</h3>
<div class="paragraph">
<p>O programa <strong>selecaobuffer.c</strong> é uma variação do código <strong>selecao.c</strong>, agora implementado utilizando buffer simples (GLUT_SINGLE) em vez de buffer duplo. Ele mantém as mesmas funcionalidades do exercício anterior: desenha quatro polígonos retangulares em uma janela de 256x256 pixels, com preenchimento inicial amarelo e bordas pretas.
A principal diferença em relação ao exercício anterior está na configuração para o uso do buffer simples.</p>
</div>
<div class="paragraph">
<p>O uso de buffer simples significa que o conteúdo é desenhado diretamente na tela, sem uma etapa intermediária. Isso pode causar flickering (tremulação ou cintilação), principalmente em aplicações com animação ou atualizações rápidas, pois a imagem pode ser parcialmente exibida durante a renderização.
No caso específico deste programa que atualiza a tela apenas em interações pontuais (como cliques e teclas) — o buffer simples é suficiente e não causa problemas visuais perceptíveis. No entanto, para aplicações mais dinâmicas ou com múltiplos elementos móveis, o uso de buffer duplo (com GLUT_DOUBLE) seria recomendado, pois evita esses efeitos indesejados ao alternar entre o buffer de desenho e o buffer de exibição.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[selecaobuffer.c]

#include &lt;GLUT/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

typedef struct {
    int x1, y1, x2, y2;
    GLfloat fillColor[3];
    GLfloat borderColor[3];
} Polygon;

Polygon polys[4];
bool changeFill = true;

void randomColor(GLfloat *color) {
    color[0] = (GLfloat)rand() / (RAND_MAX + 1.0);
    color[1] = (GLfloat)rand() / (RAND_MAX + 1.0);
    color[2] = (GLfloat)rand() / (RAND_MAX + 1.0);
}

void init(void) {
    glClearColor(1.0, 1.0, 1.0, 1.0);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0, 256, 0, 256);

    int coords[4][4] = {
        {30, 143, 113, 226},
        {143, 143, 226, 226},
        {30, 30, 113, 113},
        {143, 30, 226, 113}
    };

    for (int i = 0; i &lt; 4; i++) {
        polys[i].x1 = coords[i][0];
        polys[i].y1 = coords[i][1];
        polys[i].x2 = coords[i][2];
        polys[i].y2 = coords[i][3];
        polys[i].fillColor[0] = 1.0;
        polys[i].fillColor[1] = 1.0;
        polys[i].fillColor[2] = 0.0;
        polys[i].borderColor[0] = 0.0;
        polys[i].borderColor[1] = 0.0;
        polys[i].borderColor[2] = 0.0;
    }
}

void drawPolygon(Polygon p) {
    glColor3fv(p.fillColor);
    glBegin(GL_POLYGON);
    glVertex2i(p.x1, p.y1);
    glVertex2i(p.x2, p.y1);
    glVertex2i(p.x2, p.y2);
    glVertex2i(p.x1, p.y2);
    glEnd();

    glColor3fv(p.borderColor);
    glBegin(GL_LINE_LOOP);
    glVertex2i(p.x1, p.y1);
    glVertex2i(p.x2, p.y1);
    glVertex2i(p.x2, p.y2);
    glVertex2i(p.x1, p.y2);
    glEnd();
}

void display(void) {
    glClear(GL_COLOR_BUFFER_BIT);
    for (int i = 0; i &lt; 4; i++) {
        drawPolygon(polys[i]);
    }
    glFlush(); // Usado em buffer simples
}

void keyboard(unsigned char key, int x, int y) {
    switch (key) {
        case 'f':
        case 'F':
            changeFill = true;
            break;
        case 'b':
        case 'B':
            changeFill = false;
            break;
        case 27:
            exit(0);
            break;
    }
}

void mouse(int button, int state, int x, int y) {
    if (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_DOWN) {
        int yOpenGL = 256 - y;
        for (int i = 0; i &lt; 4; i++) {
            if (x &gt;= polys[i].x1 &amp;&amp; x &lt;= polys[i].x2 &amp;&amp;
                yOpenGL &gt;= polys[i].y1 &amp;&amp; yOpenGL &lt;= polys[i].y2) {
                if (changeFill) {
                    randomColor(polys[i].fillColor);
                } else {
                    randomColor(polys[i].borderColor);
                }
                glutPostRedisplay();
                break;
            }
        }
    }
}

int main(int argc, char **argv) {
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB); // buffer simples
    glutInitWindowSize(256, 256);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Seleção de polígonos - Buffer Simples");
    init();
    glutDisplayFunc(display);
    glutKeyboardFunc(keyboard);
    glutMouseFunc(mouse);
    glutMainLoop();
    return 0;
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="4.2.gif" alt="Saída do exercício 4.2">
</div>
<div class="title">Figure 7. Exercício 4.2</div>
</div>
</div>
<div class="sect2">
<h3 id="_exercício_3_2">Exercício 3</h3>
<div class="paragraph">
<p>O programa <strong>cf.c</strong> tem como objetivo desenhar um hexágono centrado em uma janela de 300x300 pixels, com fundo branco e preenchido com a cor azul, utilizando um padrão de preenchimento personalizado com as iniciais “CF”, representando "Clara Freitas".</p>
</div>
<div class="paragraph">
<p>O padrão foi definido como uma matriz binária de 32x32 bits codificada em um array de GLubyte, onde os bits desenham as letras C e F de forma estilizada. Para desenhar o hexágono, o programa calcula os seis vértices igualmente espaçados ao longo de um círculo com raio 100, centralizado no ponto (150, 150), utilizando funções trigonométricas. O preenchimento com padrão é ativado por meio da função glEnable(GL_POLYGON_STIPPLE), e o padrão propriamente dito é aplicado com glPolygonStipple(). O hexágono é desenhado com glBegin(GL_POLYGON) e a cor azul é definida com glColor3f(). Após o desenho, o padrão é desabilitado para evitar que afete futuras renderizações. O sistema de coordenadas ortogonais foi definido com gluOrtho2D, e a renderização é feita com buffer simples, utilizando glFlush() para atualizar a janela.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[cf.c]
#include &lt;GLUT/glut.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

#define PI 3.14159265359

// Padrão de 32x32 bits com as letras CF em binário
GLubyte cf_pattern[128] = {
  0b00000000, 0b00000000, 0b00000000, 0b00000000,
  0b00000000, 0b11111110, 0b11111110, 0b00000000,
  0b00000011, 0b00000000, 0b00000000, 0b00000000,
  0b00000100, 0b00000000, 0b00000000, 0b00000000,
  0b00001000, 0b00000000, 0b00000000, 0b00000000,
  0b00001000, 0b00000000, 0b00000000, 0b00000000,
  0b00001000, 0b00000000, 0b00000000, 0b00000000,
  0b00000100, 0b00000000, 0b00000000, 0b00000000,
  0b00000011, 0b00000000, 0b00000000, 0b00000000,
  0b00000000, 0b11111110, 0b00000000, 0b00000000,
  0b00000000, 0b00000000, 0b00000000, 0b00000000,
  0b00011111, 0b11111111, 0b00000000, 0b00000000,
  0b00000100, 0b00000000, 0b00000000, 0b00000000,
  0b00000100, 0b00000000, 0b00000000, 0b00000000,
  0b00000111, 0b11100000, 0b00000000, 0b00000000,
  0b00000100, 0b00000000, 0b00000000, 0b00000000,
  0b00000100, 0b00000000, 0b00000000, 0b00000000,
  0b00000100, 0b00000000, 0b00000000, 0b00000000,
  0b00000000, 0b00000000, 0b00000000, 0b00000000,
  0b00000000, 0b00000000, 0b00000000, 0b00000000,
  0b00000000, 0b00000000, 0b00000000, 0b00000000,
  0b00000000, 0b00000000, 0b00000000, 0b00000000,
  0b00000000, 0b00000000, 0b00000000, 0b00000000,
  0b00000000, 0b00000000, 0b00000000, 0b00000000,
  0b00000000, 0b00000000, 0b00000000, 0b00000000,
  0b00000000, 0b00000000, 0b00000000, 0b00000000,
  0b00000000, 0b00000000, 0b00000000, 0b00000000,
  0b00000000, 0b00000000, 0b00000000, 0b00000000,
  0b00000000, 0b00000000, 0b00000000, 0b00000000,
  0b00000000, 0b00000000, 0b00000000, 0b00000000,
  0b00000000, 0b00000000, 0b00000000, 0b00000000,
  0b00000000, 0b00000000, 0b00000000, 0b00000000
};

void init(void) {
    glClearColor(1.0, 1.0, 1.0, 1.0);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0, 300, 0, 300);
}

void drawHexagon(int centerX, int centerY, int radius) {
    glBegin(GL_POLYGON);
    for (int i = 0; i &lt; 6; ++i) {
        float angle = PI / 3.0 * i;
        float x = centerX + radius * cos(angle);
        float y = centerY + radius * sin(angle);
        glVertex2f(x, y);
    }
    glEnd();
}

void display(void) {
    glClear(GL_COLOR_BUFFER_BIT);

    glEnable(GL_POLYGON_STIPPLE);
    glPolygonStipple(cf_pattern);
    glColor3f(0.0, 0.0, 1.0); // Azul
    drawHexagon(150, 150, 100);
    glDisable(GL_POLYGON_STIPPLE);

    glFlush();
}

int main(int argc, char **argv) {
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(300, 300);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Hexágono com padrão CF");
    init();
    glutDisplayFunc(display);
    glutMainLoop();
    return 0;
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="4.3.png" alt="Saída do exercício 4.3">
</div>
<div class="title">Figure 8. Exercício 4.3</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_capítulo_5">Capítulo 5</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo tem como objetivo compreender como as transformações geométricas são aplicadas a objetos gráficos em relação a um sistema de coordenadas.</p>
</div>
<div class="sect2">
<h3 id="_exercício_1_4">Exercício 1</h3>
<div class="paragraph">
<p>O programa <strong>braco-garra.c</strong> estende o exemplo original do braço robótico (braco.c) ao adicionar uma garra composta por três dedos articuláveis: indicador, médio e polegar. O braço mantém sua estrutura com dois segmentos (ombro e antebraço), sendo possível rotacioná-los por meio das teclas 's/S' e 'e/E'. A principal adição é feita ao final do braço, onde são desenhados três cubos representando os dedos, cada um com transformações específicas de posição e rotação. O dedo indicador é manipulado pelas teclas 'i' e 'I', o médio por 'm' e 'M', e o polegar por 'p' e 'P', permitindo rotação individual de cada um. O polegar, diferentemente dos demais, é rotacionado em torno do eixo X, simulando um movimento mais anatômico. Cada dedo é posicionado em relação à extremidade do braço utilizando glTranslatef, rotacionado com glRotatef, e escalado com glScalef para representar a forma alongada. A exibição é feita com glutWireCube, e o uso do glPushMatrix e glPopMatrix garante que as transformações sejam isoladas para cada componente do modelo. O programa utiliza perspectiva com gluPerspective e buffer duplo para uma renderização suave.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[braco-garra.c]
#include &lt;GLUT/glut.h&gt;
#include &lt;stdlib.h&gt;

static int shoulder = 0, elbow = 0;
static int indicator = 0, middle = 0, thumb = 0; // New variables for finger rotation

void init(void){
  glClearColor (0.0, 0.0, 0.0, 0.0);
  glShadeModel (GL_FLAT); // Added for consistent shading
}

void display(void){
  glClear (GL_COLOR_BUFFER_BIT);
  glPushMatrix();

  /* origin positioned at the shoulder */
  glTranslatef (-1.0, 0.0, 0.0);
  glRotatef ((GLfloat) shoulder, 0.0, 0.0, 1.0);

  /* origin positioned at the center of the upper arm */
  glTranslatef (1.0, 0.0, 0.0);
  glPushMatrix();
  glScalef (2.0, 0.4, 1.0);
  glutWireCube (1.0);
  glPopMatrix();

  /* origin positioned at the elbow */
  glTranslatef (1.0, 0.0, 0.0);
  glRotatef ((GLfloat) elbow, 0.0, 0.0, 1.0);
  glTranslatef (1.0, 0.0, 0.0); // This translation puts the origin at the end of the elbow
  glPushMatrix();
  glScalef (2.0, 0.4, 1.0);
  glutWireCube (1.0);
  glPopMatrix();

  // --- Gripper (Garra) Implementation ---
  // Translate to the end of the last segment (elbow)
  // Now add the fingers from this point

  // Indicator finger
  glPushMatrix();
  glTranslatef(1.0, 0.2, 0.0); // Position the indicator finger relative to the elbow end
  glRotatef((GLfloat) indicator, 0.0, 0.0, 1.0); // Rotate the indicator finger
  glTranslatef(0.2, 0.0, 0.0); // Adjust origin to center of finger for scaling
  glScalef(0.4, 0.2, 0.2); // Scale to look like a finger
  glutWireCube(1.0);
  glPopMatrix();

  // Middle finger
  glPushMatrix();
  glTranslatef(1.0, -0.2, 0.0); // Position the middle finger
  glRotatef((GLfloat) middle, 0.0, 0.0, 1.0); // Rotate the middle finger
  glTranslatef(0.2, 0.0, 0.0); // Adjust origin to center of finger for scaling
  glScalef(0.4, 0.2, 0.2); // Scale to look like a finger
  glutWireCube(1.0);
  glPopMatrix();

  // Thumb finger
  glPushMatrix();
  glTranslatef(0.8, -0.2, -0.5); // Position the thumb finger
  glRotatef((GLfloat) thumb, 1.0, 0.0, 0.0); // Rotate the thumb finger (around X-axis for thumb-like movement)
  glTranslatef(0.0, -0.2, 0.2); // Adjust origin to center of finger for scaling
  glScalef(0.2, 0.4, 0.2); // Scale to look like a thumb
  glutWireCube(1.0);
  glPopMatrix();
  // --- End of Gripper (Garra) Implementation ---


  /* origin returns to the original coordinate system */
  glPopMatrix();
  glutSwapBuffers();
}

void reshape (int w, int h){
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glTranslatef (0.0, 0.0, -5.0);
}

void keyboard (unsigned char key, int x, int y){
  switch (key) {
  case 's':
    shoulder = (shoulder + 5) % 360;
    glutPostRedisplay();
    break;
  case 'S':
    shoulder = (shoulder - 5) % 360;
    glutPostRedisplay();
    break;
  case 'e':
    elbow = (elbow + 5) % 360;
    glutPostRedisplay();
    break;
  case 'E':
    elbow = (elbow - 5) % 360;
    glutPostRedisplay();
    break;
  case 'i': // Rotate indicator clockwise
    indicator = (indicator + 5) % 360;
    glutPostRedisplay();
    break;
  case 'I': // Rotate indicator anti-clockwise
    indicator = (indicator - 5) % 360;
    glutPostRedisplay();
    break;
  case 'm': // Rotate middle clockwise
    middle = (middle + 5) % 360;
    glutPostRedisplay();
    break;
  case 'M': // Rotate middle anti-clockwise
    middle = (middle - 5) % 360;
    glutPostRedisplay();
    break;
  case 'p': // Rotate thumb clockwise
    thumb = (thumb + 5) % 360;
    glutPostRedisplay();
    break;
  case 'P': // Rotate thumb anti-clockwise
    thumb = (thumb - 5) % 360;
    glutPostRedisplay();
    break;
  case 27:
    exit(0);
    break;
  default:
    break;
  }
}

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize (500, 500);
  glutInitWindowPosition (100, 100);
  glutCreateWindow (argv[0]);
  init ();
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="5.1.png" alt="Saída do exercicio 5.1">
</div>
<div class="title">Figure 9. Exercício 5.1</div>
</div>
</div>
<div class="sect2">
<h3 id="_exercício_2_4">Exercício 2</h3>
<div class="paragraph">
<p>O programa <strong>braco-garra-3d.c</strong> é uma extensão tridimensional do braço robótico com garra. Ele utiliza o modo de exibição com suporte a profundidade e remoção de superfícies escondidas, ativados por meio da função glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH) e pelas chamadas glEnable(GL_DEPTH_TEST) e glEnable(GL_CULL_FACE) dentro da função init(). Além disso, todas as primitivas gráficas foram alteradas de glutWireCube() para glutSolidCube(), permitindo uma visualização mais realista dos sólidos em 3D. O braço é composto por segmentos articulados (ombro e cotovelo), cada um com uma cor distinta para facilitar a identificação visual: vermelho para o ombro e verde para o antebraço. A garra, localizada na extremidade do braço, é formada por três dedos (indicador, médio e polegar), cada um representado por um cubo sólido com rotação independente controlada por teclas específicas. O dedo indicador é azul, o médio é ciano e o polegar é amarelo. O programa também introduz um controle para a base do robô, permitindo sua rotação no eixo Y por meio das teclas 'b' e 'B'. Essa rotação faz com que todo o braço gire horizontalmente, simulando um movimento de rotação da base da estrutura robótica. O uso de transformações hierárquicas com glPushMatrix() e glPopMatrix() permite que cada parte do braço se mova de forma coordenada, mantendo sua posição relativa às demais.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[braco-garra3d.c]

#include &lt;GLUT/glut.h&gt;
#include &lt;stdlib.h&gt;

static int shoulder = 0, elbow = 0;
static int indicator = 0, middle = 0, thumb = 0;
static int base = 0; // New variable for base rotation

void init(void){
  glClearColor (0.0, 0.0, 0.0, 0.0);
  glShadeModel (GL_FLAT);
  glEnable(GL_DEPTH_TEST); // Enable depth testing
  glEnable(GL_CULL_FACE);  // Enable face culling
}

void display(void){
  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear depth buffer as well
  glPushMatrix();

  // Rotate the entire arm around the Y-axis for the base rotation
  glRotatef((GLfloat) base, 0.0, 1.0, 0.0);

  /* origin positioned at the shoulder */
  glTranslatef (-1.0, 0.0, 0.0);
  glRotatef ((GLfloat) shoulder, 0.0, 0.0, 1.0);

  /* origin positioned at the center of the upper arm */
  glTranslatef (1.0, 0.0, 0.0);
  glPushMatrix();
  glColor3f(1.0, 0.0, 0.0); // Red color for the shoulder
  glScalef (2.0, 0.4, 1.0);
  glutSolidCube (1.0); // Use glutSolidCube
  glPopMatrix();

  /* origin positioned at the elbow */
  glTranslatef (1.0, 0.0, 0.0);
  glRotatef ((GLfloat) elbow, 0.0, 0.0, 1.0);
  glTranslatef (1.0, 0.0, 0.0); // This translation puts the origin at the end of the elbow
  glPushMatrix();
  glColor3f(0.0, 1.0, 0.0); // Green color for the elbow
  glScalef (2.0, 0.4, 1.0);
  glutSolidCube (1.0); // Use glutSolidCube
  glPopMatrix();

  // --- Gripper (Garra) Implementation ---
  // Translate to the end of the last segment (elbow)
  // Now add the fingers from this point

  // Indicator finger (Blue)
  glPushMatrix();
  glColor3f(0.0, 0.0, 1.0); // Blue color for indicator
  glTranslatef(1.0, 0.2, 0.0); // Position the indicator finger relative to the elbow end
  glRotatef((GLfloat) indicator, 0.0, 0.0, 1.0); // Rotate the indicator finger
  glTranslatef(0.2, 0.0, 0.0); // Adjust origin to center of finger for scaling
  glScalef(0.4, 0.2, 0.2); // Scale to look like a finger
  glutSolidCube(1.0); // Use glutSolidCube
  glPopMatrix();

  // Middle finger (Cyan)
  glPushMatrix();
  glColor3f(0.0, 1.0, 1.0); // Cyan color for middle
  glTranslatef(1.0, -0.2, 0.0); // Position the middle finger
  glRotatef((GLfloat) middle, 0.0, 0.0, 1.0); // Rotate the middle finger
  glTranslatef(0.2, 0.0, 0.0); // Adjust origin to center of finger for scaling
  glScalef(0.4, 0.2, 0.2); // Scale to look like a finger
  glutSolidCube(1.0); // Use glutSolidCube
  glPopMatrix();

  // Thumb finger (Yellow)
  glPushMatrix();
  glColor3f(1.0, 1.0, 0.0); // Yellow color for thumb
  glTranslatef(0.8, -0.2, -0.5); // Position the thumb finger
  glRotatef((GLfloat) thumb, 1.0, 0.0, 0.0); // Rotate the thumb finger (around X-axis for thumb-like movement)
  glTranslatef(0.0, -0.2, 0.2); // Adjust origin to center of finger for scaling
  glScalef(0.2, 0.4, 0.2); // Scale to look like a thumb
  glutSolidCube(1.0); // Use glutSolidCube
  glPopMatrix();
  // --- End of Gripper (Garra) Implementation ---

  /* origin returns to the original coordinate system */
  glPopMatrix();
  glutSwapBuffers();
}

void reshape (int w, int h){
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glTranslatef (0.0, 0.0, -5.0);
}

void keyboard (unsigned char key, int x, int y){
  switch (key) {
  case 's':
    shoulder = (shoulder + 5) % 360;
    glutPostRedisplay();
    break;
  case 'S':
    shoulder = (shoulder - 5) % 360;
    glutPostRedisplay();
    break;
  case 'e':
    elbow = (elbow + 5) % 360;
    glutPostRedisplay();
    break;
  case 'E':
    elbow = (elbow - 5) % 360;
    glutPostRedisplay();
    break;
  case 'i': // Rotate indicator clockwise
    indicator = (indicator + 5) % 360;
    glutPostRedisplay();
    break;
  case 'I': // Rotate indicator anti-clockwise
    indicator = (indicator - 5) % 360;
    glutPostRedisplay();
    break;
  case 'm': // Rotate middle clockwise
    middle = (middle + 5) % 360;
    glutPostRedisplay();
    break;
  case 'M': // Rotate middle anti-clockwise
    middle = (middle - 5) % 360;
    glutPostRedisplay();
    break;
  case 'p': // Rotate thumb clockwise
    thumb = (thumb + 5) % 360;
    glutPostRedisplay();
    break;
  case 'P': // Rotate thumb anti-clockwise
    thumb = (thumb - 5) % 360;
    glutPostRedisplay();
    break;
  case 'b': // Rotate base clockwise
    base = (base + 5) % 360;
    glutPostRedisplay();
    break;
  case 'B': // Rotate base anti-clockwise
    base = (base - 5) % 360;
    glutPostRedisplay();
    break;
  case 27:
    exit(0);
    break;
  default:
    break;
  }
}

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH); // Changed display mode
  glutInitWindowSize (500, 500);
  glutInitWindowPosition (100, 100);
  glutCreateWindow (argv[0]);
  init ();
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutKeyboardFunc(keyboard);
  glutMainLoop();
  return 0;
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="5.2.png" alt="Saída do Exercício 5.2">
</div>
<div class="title">Figure 10. Exercício 5.2</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_capítulo_6">Capítulo 6</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo tem como objetivo compreender o funcionamento dos principais tipos de projeções geométricas utilizadas em ambientes gráficos, com ênfase nas projeções paralelas e projeções em perspectiva.</p>
</div>
<div class="sect2">
<h3 id="_exercício_1_5">Exercício 1</h3>
<div class="paragraph">
<p>O programa <strong>tiposdeprojecoes.c</strong> foi implementado com base no exemplo <strong>projecoes.c</strong>, com o objetivo de permitir a visualização individual de diferentes faces de um objeto 3D por meio de teclas específicas.</p>
</div>
<div class="paragraph">
<p>Para isso, foi criada uma variável global chamada modoAtual, baseada em um enum, que define qual parte do objeto deve ser exibida na tela. Foram adicionadas sete novas opções de teclado: 't' para mostrar o topo, 'f' para o fundo, 'F' para a frente, 'T' para a face traseira, 'e' para a face esquerda, 'd' para a direita, e 'c' para exibir apenas o triângulo do canto. Além disso, a tecla 'r' foi incluída para restaurar a visualização completa de todas as faces. A função display() foi adaptada para desenhar somente a parte selecionada com base no valor de modoAtual, utilizando as cores e índices definidos para cada face. O restante da estrutura do programa, como rotação com as teclas 'x', 'X', 'y', 'Y' e os modos de projeção com 'p' (perspectiva) e 'o' (ortográfica), foi mantido conforme o código original.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[tiposdeprojecao.c]

#include &lt;GLUT/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

// Enum para tornar o código mais legível. Define os possíveis modos de exibição.
typedef enum {
    TODAS, TOPO, FUNDO, FRENTE, TRASEIRA, ESQUERDA, DIREITA, CANTO
} ModoExibicao;

// Variável global para armazenar o modo de exibição atual
ModoExibicao modoAtual = TODAS;

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void reshape (int w, int h);

#define AZUL     0.0, 0.0, 1.0
#define VERMELHO 1.0, 0.0, 0.0
#define AMARELO  1.0, 1.0, 0.0
#define VERDE    0.0, 1.0, 0.0
#define CYAN     0.0, 1.0, 1.0  // Corrigido para Cyan (era Magenta)
#define LARANJA  0.8, 0.6, 0.1
#define ROSEO    0.7, 0.1, 0.6
#define CINZA    0.6, 0.6, 0.6

static GLfloat vertices[30]={
  0.0,  30.0, 30.0, /* 0 */
  20.0, 30.0, 30.0, /* 1 */
  30.0, 20.0, 30.0, /* 2 */
  30.0,  0.0, 30.0, /* 3 */
  0.0,   0.0, 30.0, /* 4 */
  0.0,  30.0,  0.0, /* 5 */
  30.0, 30.0,  0.0, /* 6 */
  30.0,  0.0,  0.0, /* 7 */
  0.0,   0.0,  0.0, /* 8 */
  30.0, 30.0, 20.0  /* 9 */
};

static GLubyte frenteIndices[]    = {0,4,3,2,1};
static GLubyte trasIndices[]      = {5,6,7,8};
static GLubyte esquerdaIndices[]  = {0,5,8,4};
static GLubyte direitaIndices[]   = {2,3,7,6,9};
static GLubyte topoIndices[]      = {0,1,9,6,5};
static GLubyte fundoIndices[]     = {3,4,8,7};
static GLubyte trianguloIndices[] = {1,2,9};

static int eixoy, eixox;
int largura, altura;

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
  glutInitWindowSize (500, 500);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("Tipos de Projecoes");
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutReshapeFunc(reshape);
  glutMainLoop();
  return 0;
}

void init(void){
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glOrtho (-50, 50, -50, 50, -50 , 50);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE);
}

void reshape (int w, int h){
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  largura=w;
  altura=h;
}

void display(void){
  glPushMatrix();
  glRotatef ((GLfloat) eixoy, 0.0, 1.0, 0.0);
  glRotatef ((GLfloat) eixox, 1.0, 0.0, 0.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

  glEnableClientState(GL_VERTEX_ARRAY);
  glVertexPointer(3, GL_FLOAT, 0, vertices);

  // Usa o modo de exibição atual para decidir o que desenhar
  switch (modoAtual) {
    case TODAS:
      glColor3f (AZUL);
      glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, frenteIndices);
      glColor3f (AMARELO);
      glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, esquerdaIndices);
      glColor3f (VERMELHO);
      glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, trasIndices);
      glColor3f (VERDE);
      glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, direitaIndices);
      glColor3f (CYAN);
      glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, topoIndices);
      glColor3f (LARANJA);
      glDrawElements(GL_QUADS, 4, GL_UNSIGNED_BYTE, fundoIndices);
      glColor3f (CINZA);
      glDrawElements(GL_POLYGON, 3, GL_UNSIGNED_BYTE, trianguloIndices);
      break;
    case TOPO:
      glColor3f (CYAN); /* topo */
      glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, topoIndices);
      break;
    case FUNDO:
      glColor3f (LARANJA); /* fundo */
      glDrawElements(GL_QUADS, 4, GL_UNSIGNED_BYTE, fundoIndices);
      break;
    case FRENTE:
      glColor3f (AZUL); /* frente */
      glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, frenteIndices);
      break;
    case TRASEIRA:
      glColor3f (VERMELHO); /* tras */
      glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, trasIndices);
      break;
    case ESQUERDA:
      glColor3f (AMARELO); /* esquerda */
      glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, esquerdaIndices);
      break;
    case DIREITA:
      glColor3f (VERDE); /* direita */
      glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, direitaIndices);
      break;
    case CANTO:
      glColor3f (CINZA); /* triangulo do canto */
      glDrawElements(GL_POLYGON, 3, GL_UNSIGNED_BYTE, trianguloIndices);
      break;
  }

  glDisableClientState (GL_VERTEX_ARRAY);

  glPopMatrix();
  glutSwapBuffers();
}

void keyboard(unsigned char key, int x, int y){
  switch (key) {
    case 27: // ESC
      exit(0);
      break;
    // Teclas para exibir faces individuais
    case 't': // topo
      modoAtual = TOPO;
      break;
    case 'f': // fundo
      modoAtual = FUNDO;
      break;
    case 'F': // Frente
      modoAtual = FRENTE;
      break;
    case 'T': // Traseira
      modoAtual = TRASEIRA;
      break;
    case 'e': // esquerda
      modoAtual = ESQUERDA;
      break;
    case 'd': // direita
      modoAtual = DIREITA;
      break;
    case 'c': // canto (triângulo)
      modoAtual = CANTO;
      break;
    // Tecla para restaurar a visualização de todas as faces
    case 'r':
      modoAtual = TODAS;
      break;
    // Controles de rotação
    case 'y':
      eixoy = (eixoy + 5) % 360;
      break;
    case 'Y':
      eixoy = (eixoy - 5) % 360;
      break;
    case 'x':
      eixox = (eixox + 5) % 360;
      break;
    case 'X':
      eixox = (eixox - 5) % 360;
      break;
    // Controles de projeção
    case 'p':
      glLoadIdentity();
      gluPerspective(65.0, (GLfloat) largura/(GLfloat) altura, 20.0, 120.0);
      gluLookAt(0, 0, -90, 0, 0, 0, 0, 1, 0);
      break;
    case 'o':
      glLoadIdentity();
      glOrtho (-50, 50, -50, 50, -50 , 50);
      modoAtual = TODAS; // Restaura para a visão ortográfica com todos os objetos
      break;
  }
  glutPostRedisplay(); // Solicita que a tela seja redesenhada
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="6.1.gif" alt="Saída do Exercício 6.1">
</div>
<div class="title">Figure 11. Exercício 6.1</div>
</div>
</div>
<div class="sect2">
<h3 id="_exercício_2_5">Exercício 2</h3>
<div class="paragraph">
<p>O programa <strong>projecaoidle.c</strong> foi desenvolvido a partir do exemplo <strong>projecoes.c</strong> com o objetivo de implementar uma animação contínua do objeto utilizando a função glutIdleFunc(). Essa função permite que uma rotina seja executada continuamente em segundo plano, enquanto a aplicação está ociosa, ou seja, sem eventos pendentes de entrada.</p>
</div>
<div class="paragraph">
<p>Para isso, foi criada a função idle(), na qual os ângulos de rotação eixox e eixoy são incrementados com valores pequenos e diferentes (0.4 e 0.8), proporcionando uma rotação suave e contínua da figura em ambos os eixos. Para controlar a velocidade da animação e torná-la visualmente agradável, foi utilizada a função usleep(16000), que introduz um pequeno atraso entre os quadros, resultando em aproximadamente 60 atualizações por segundo. A função idle() é registrada no main() através de glutIdleFunc(idle), garantindo que a rotação aconteça automaticamente mesmo sem interação do usuário. O programa ainda mantém as teclas 'p' e 'o' para alternar entre projeções em perspectiva e ortográfica, respectivamente, ajustando a matriz de projeção conforme necessário.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[projecaoidle.c]

#include &lt;GLUT/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt; // Necessário para a função usleep()

void init(void);
void display(void);
void keyboard(unsigned char key, int x, int y);
void reshape (int w, int h);
void idle(void); // Protótipo da nova função idle

#define AZUL     0.0, 0.0, 1.0
#define VERMELHO 1.0, 0.0, 0.0
#define AMARELO  1.0, 1.0, 0.0
#define VERDE    0.0, 1.0, 0.0
#define CYAN     0.0, 1.0, 1.0
#define LARANJA  0.8, 0.6, 0.1
#define ROSEO    0.7, 0.1, 0.6
#define CINZA    0.6, 0.6, 0.6

static GLfloat vertices[30]={
  0.0,  30.0, 30.0, /* 0 */
  20.0, 30.0, 30.0, /* 1 */
  30.0, 20.0, 30.0, /* 2 */
  30.0,  0.0, 30.0, /* 3 */
  0.0,   0.0, 30.0, /* 4 */
  0.0,  30.0,  0.0, /* 5 */
  30.0, 30.0,  0.0, /* 6 */
  30.0,  0.0,  0.0, /* 7 */
  0.0,   0.0,  0.0, /* 8 */
  30.0, 30.0, 20.0  /* 9 */
};

static GLubyte frenteIndices[]    = {0,4,3,2,1};
static GLubyte trasIndices[]      = {5,6,7,8};
static GLubyte esquerdaIndices[]  = {0,5,8,4};
static GLubyte direitaIndices[]   = {2,3,7,6,9};
static GLubyte topoIndices[]      = {0,1,9,6,5};
static GLubyte fundoIndices[]     = {3,4,8,7};
static GLubyte trianguloIndices[] = {1,2,9};

// Ângulos de rotação, inicializados em 0
static GLfloat eixoy = 0.0, eixox = 0.0;
int largura, altura;

// --- Nova Função Idle ---
// Esta função é chamada pelo GLUT quando não há outros eventos a serem processados.
void idle(void){
    // Incrementa os ângulos de rotação com valores constantes e diferentes
    eixox += 0.4f;
    eixoy += 0.8f;

    // Garante que os ângulos permaneçam dentro do intervalo 0-360
    if(eixox &gt; 360) eixox -= 360;
    if(eixoy &gt; 360) eixoy -= 360;

    // Solicita que a janela seja redesenhada para mostrar o próximo quadro da animação
    glutPostRedisplay();

    // Introduz um pequeno atraso (em microssegundos) para controlar a velocidade.
    // 16000 microssegundos ≈ 60 quadros por segundo (1.000.000 / 60 ≈ 16666)
    usleep(16000);
}

int main(int argc, char** argv){
  glutInit(&amp;argc, argv);
  glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
  glutInitWindowSize (500, 500);
  glutInitWindowPosition (100, 100);
  glutCreateWindow ("Animacao com glutIdleFunc");
  init();
  glutDisplayFunc(display);
  glutKeyboardFunc(keyboard);
  glutReshapeFunc(reshape);
  glutIdleFunc(idle); // &lt;-- REGISTRA A FUNÇÃO IDLE AQUI
  glutMainLoop();
  return 0;
}

void init(void){
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glOrtho (-50, 50, -50, 50, -50 , 50);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE);
}

void reshape (int w, int h){
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  largura=w;
  altura=h;
}

void display(void){
  glPushMatrix();
  glRotatef (eixoy, 0.0, 1.0, 0.0);
  glRotatef (eixox, 1.0, 0.0, 0.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

  glEnableClientState(GL_VERTEX_ARRAY);
  glVertexPointer(3, GL_FLOAT, 0, vertices);

  glColor3f (AZUL); /* frente */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, frenteIndices);
  glColor3f (AMARELO); /* esquerda */
  glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, esquerdaIndices);
  glColor3f (VERMELHO); /* tras */
  glDrawElements(GL_POLYGON, 4, GL_UNSIGNED_BYTE, trasIndices);
  glColor3f (VERDE); /* direita */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, direitaIndices);
  glColor3f (CYAN); /* topo */
  glDrawElements(GL_POLYGON, 5, GL_UNSIGNED_BYTE, topoIndices);
  glColor3f (LARANJA); /* fundo */
  glDrawElements(GL_QUADS, 4, GL_UNSIGNED_BYTE, fundoIndices);
  glColor3f (CINZA); /* triangulo */
  glDrawElements(GL_POLYGON, 3, GL_UNSIGNED_BYTE, trianguloIndices);

  glDisableClientState (GL_VERTEX_ARRAY);

  glPopMatrix();
  glutSwapBuffers();
}

void keyboard(unsigned char key, int x, int y){
  switch (key) {
    case 27: // Tecla ESC para sair
      exit(0);
      break;
    // Teclas para alternar a projeção continuam funcionando
    case 'p':
      glMatrixMode(GL_PROJECTION);
      glLoadIdentity();
      gluPerspective(65.0, (GLfloat) largura/(GLfloat) altura, 20.0, 120.0);
      glMatrixMode(GL_MODELVIEW);
      glLoadIdentity();
      // Ajusta a câmera para a projeção de perspectiva
      gluLookAt(0, 0, 90, 0, 0, 0, 0, 1, 0);
      break;
    case 'o':
      glMatrixMode(GL_PROJECTION);
      glLoadIdentity();
      glOrtho (-50, 50, -50, 50, -50 , 50);
      glMatrixMode(GL_MODELVIEW);
      glLoadIdentity();
      break;
  }
  // Não é estritamente necessário chamar glutPostRedisplay aqui,
  // pois a função idle() já faz isso continuamente.
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="6.2.gif" alt="Saída do Exercício 6.2">
</div>
<div class="title">Figure 12. Exercício 6.2</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_capítulo_7">Capítulo 7</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo tem como objetivo demonstrar a geração, em um plano, das curvas paramétricas mais comuns utilizadas no OpenGL: as curvas de Bézier e as curvas NURBS (Non-Uniform Rational B-Splines).</p>
</div>
<div class="sect2">
<h3 id="_exercício_1_6">Exercício 1</h3>
<div class="paragraph">
<p>Neste exercício, foi implementado o programa <strong>splinesnurbs.c</strong>, baseado no exemplo <strong>splines2d.c</strong>, com o objetivo de desenhar curvas de Bézier e curvas NURBS utilizando OpenGL. A aplicação permite alternar entre os dois tipos de curva pressionando a tecla correspondente no teclado, além de possibilitar a movimentação dos pontos de controle com o mouse. A principal modificação feita foi a inclusão de três modos distintos de geração da curva NURBS, dependendo do tipo de vetor de nós utilizado: uniforme, uniforme aberto e não uniforme, ativados respectivamente pelas teclas u, o e n.</p>
</div>
<div class="paragraph">
<p>As curvas de Bézier foram implementadas com as funções glMap1f e glEvalCoord1f, e são construídas com base em todos os pontos de controle, o que significa que qualquer alteração em um ponto afeta a forma global da curva. Elas sempre começam no primeiro ponto de controle e terminam no último, e sua principal característica é a simplicidade de implementação, embora ofereçam menos flexibilidade local. Já as curvas NURBS foram implementadas com a função gluNurbsCurve, utilizando um objeto GLUnurbs e um vetor de nós (knot vector). Diferentemente das curvas de Bézier, as NURBS permitem maior controle local sobre a forma da curva e maior flexibilidade para representar formas complexas, graças à presença do vetor de nós. O comportamento da curva muda conforme esse vetor: quando o vetor é uniforme, os nós são igualmente espaçados e a curva se apresenta suave, mas com menos controle em regiões específicas; quando é uniforme aberto, os nós iniciais e finais se repetem conforme o grau da curva, fazendo com que ela comece no primeiro ponto e termine no último, como ocorre com as curvas de Bézier; e quando o vetor é não uniforme, os nós têm espaçamentos irregulares, o que permite controle mais detalhado sobre a forma da curva e regiões com curvatura mais acentuada.</p>
</div>
<div class="paragraph">
<p>Foi possível observar que, ao variar a ordem da curva NURBS, há mudanças significativas no seu comportamento. Para curvas de ordem 3 (grau 2), a aproximação aos pontos de controle é maior e as transições são mais perceptíveis, tornando a curva mais angulosa. Já curvas de ordem 5 (grau 4) resultam em formas mais suaves e fluídas, com transições gradativas entre os segmentos, embora a curva se afaste mais dos pontos de controle. Isso demonstra que ordens maiores proporcionam maior suavidade, porém sacrificam o controle local.</p>
</div>
<div class="paragraph">
<p>Por fim, comparando curvas de Bézier com NURBS de mesma ordem, nota-se que as curvas NURBS são mais versáteis. Enquanto as curvas de Bézier têm comportamento global — ou seja, uma modificação em qualquer ponto afeta toda a curva — as NURBS permitem controle local, onde apenas uma região da curva é afetada. Além disso, as NURBS podem ser adaptadas para representar formas exatas, como arcos de círculo, o que não é possível com as curvas de Bézier. Com isso, conclui-se que as curvas NURBS oferecem uma solução mais robusta para modelagem gráfica, principalmente quando se deseja maior controle e fidelidade na forma.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[splinesnurb.c]

#include &lt;OpenGL/gl.h&gt;
#include &lt;OpenGL/glu.h&gt;
#include &lt;GLUT/glut.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MAX_POINTS 20

GLfloat vertices[MAX_POINTS][3];
int nVertices = 0;
int movingPoint = -1;

GLUnurbsObj *nurbs;

GLint grau = 3; // Grau da curva
GLint tipoNos = 0; // 0: uniforme, 1: uniforme aberto, 2: não uniforme

GLfloat nos_uniforme[MAX_POINTS + 10];
GLfloat nos_uniforme_aberto[MAX_POINTS + 10];
GLfloat nos_nao_uniforme[MAX_POINTS + 10];

void initNos() {
    int nCtrlPts = nVertices;
    int nNos = nCtrlPts + grau + 1;

    // Uniforme
    for (int i = 0; i &lt; nNos; i++)
        nos_uniforme[i] = (GLfloat)i;

    // Uniforme aberto
    for (int i = 0; i &lt;= grau; i++)
        nos_uniforme_aberto[i] = 0.0f;
    for (int i = grau + 1; i &lt; nCtrlPts; i++)
        nos_uniforme_aberto[i] = i - grau;
    for (int i = nCtrlPts; i &lt; nNos; i++)
        nos_uniforme_aberto[i] = nCtrlPts - grau;

    // Não uniforme (exemplo customizado)
    for (int i = 0; i &lt; nNos; i++) {
        if (i &lt; grau + 1)
            nos_nao_uniforme[i] = 0.0f;
        else if (i &gt;= nCtrlPts)
            nos_nao_uniforme[i] = 1.0f;
        else
            nos_nao_uniforme[i] = (GLfloat)(rand() % 100) / 100.0f;
    }
}

void desenhaCurva() {
    if (nVertices &lt; grau + 1) return;

    int nNos = nVertices + grau + 1;
    GLfloat *nó_usado = NULL;

    switch (tipoNos) {
        case 0: nó_usado = nos_uniforme; break;
        case 1: nó_usado = nos_uniforme_aberto; break;
        case 2: nó_usado = nos_nao_uniforme; break;
    }

    gluBeginCurve(nurbs);
    gluNurbsCurve(nurbs, nNos, nó_usado, 3, &amp;vertices[0][0], grau + 1, GL_MAP1_VERTEX_3);
    gluEndCurve(nurbs);
}

void display(void) {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // Desenha pontos de controle
    glPointSize(5.0);
    glColor3f(1.0, 0.0, 0.0);
    glBegin(GL_POINTS);
    for (int i = 0; i &lt; nVertices; i++)
        glVertex3fv(vertices[i]);
    glEnd();

    // Desenha linhas entre pontos
    glColor3f(0.5, 0.5, 0.5);
    glBegin(GL_LINE_STRIP);
    for (int i = 0; i &lt; nVertices; i++)
        glVertex3fv(vertices[i]);
    glEnd();

    // Desenha curva
    glColor3f(0.0, 0.0, 1.0);
    desenhaCurva();

    glutSwapBuffers();
}

void reshape(int w, int h) {
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0.0, 500.0, 0.0, 500.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

void keyboard(unsigned char key, int x, int y) {
    switch (key) {
        case 'u':
            tipoNos = 0;
            printf("Usando vetor de nós uniforme.\n");
            glutPostRedisplay();
            break;
        case 'o':
            tipoNos = 1;
            printf("Usando vetor de nós uniforme aberto.\n");
            glutPostRedisplay();
            break;
        case 'n':
            tipoNos = 2;
            printf("Usando vetor de nós não uniforme.\n");
            glutPostRedisplay();
            break;
        case 27:
            exit(0);
    }
}

void mouse(int button, int state, int x, int y) {
    float fx = (float)x;
    float fy = 500.0f - (float)y;

    if (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_DOWN) {
        for (int i = 0; i &lt; nVertices; i++) {
            if (abs(fx - vertices[i][0]) &lt; 5.0 &amp;&amp; abs(fy - vertices[i][1]) &lt; 5.0) {
                movingPoint = i;
                return;
            }
        }
        if (nVertices &lt; MAX_POINTS) {
            vertices[nVertices][0] = fx;
            vertices[nVertices][1] = fy;
            vertices[nVertices][2] = 0.0;
            nVertices++;
            initNos();
            glutPostRedisplay();
        }
    }

    if (button == GLUT_LEFT_BUTTON &amp;&amp; state == GLUT_UP) {
        movingPoint = -1;
    }
}

void motion(int x, int y) {
    if (movingPoint &gt;= 0) {
        vertices[movingPoint][0] = (float)x;
        vertices[movingPoint][1] = 500.0f - (float)y;
        glutPostRedisplay();
    }
}

void init(void) {
    nurbs = gluNewNurbsRenderer();
    gluNurbsProperty(nurbs, GLU_SAMPLING_TOLERANCE, 25.0);
    glClearColor(1.0, 1.0, 1.0, 1.0);
}

int main(int argc, char **argv) {
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(500, 500);
    glutCreateWindow("splinesnurbs.c");

    init();

    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutKeyboardFunc(keyboard);
    glutMouseFunc(mouse);
    glutMotionFunc(motion);

    glutMainLoop();
    return 0;
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="7.1.png" alt="Saída do Exercício 7.1">
</div>
<div class="title">Figure 13. Exercício 7.1</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_capítulo_8">Capítulo 8</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O objetivo deste capítulo é demonstrar a geração, no espaço tridimensional, das superfícies paramétricas de Bézier e NURBS (Non-Uniform Rational B-Splines).</p>
</div>
<div class="sect2">
<h3 id="_exercício_1_7">Exercício 1</h3>
<div class="paragraph">
<p>Neste exercício, foi desenvolvido o programa <strong>splineinter.c</strong>, cujo objetivo é permitir a modelagem interativa de superfícies utilizando curvas NURBS ou de Bézier. Baseando-se nas técnicas de seleção de objetos apresentadas no capítulo sobre superfícies em espaço tridimensional, o programa possibilita que o usuário selecione e mova pontos da malha de controle com o mouse, modificando dinamicamente a forma da superfície renderizada.</p>
</div>
<div class="paragraph">
<p>A interação ocorre quando o botão esquerdo do mouse é pressionado: o programa utiliza a função gluUnProject() duas vezes — uma com o parâmetro de profundidade winz = 0 (plano próximo) e outra com winz = 1 (plano distante) — para calcular um raio que parte da posição do cursor do mouse em direção ao espaço 3D. Com isso, é possível determinar a direção do raio de seleção e compará-lo com a posição dos pontos da malha de controle. Para cada ponto, calcula-se a distância até o raio com base na projeção do ponto sobre a reta gerada. O ponto de controle mais próximo do raio é então selecionado, desde que esteja dentro de uma distância mínima aceitável.</p>
</div>
<div class="paragraph">
<p>Após a seleção, o usuário pode mover o ponto arrastando o mouse. O movimento do ponto selecionado é calculado projetando sua posição atual na tela para obter a profundidade (winZ) e, em seguida, convertendo a nova posição do cursor de volta para o espaço 3D mantendo essa profundidade constante. Isso faz com que o ponto se mova de forma coerente em um plano paralelo ao plano da tela.</p>
</div>
<div class="paragraph">
<p>Com essa funcionalidade interativa, o usuário tem controle direto sobre a forma da superfície, podendo explorar de forma intuitiva o impacto dos pontos de controle sobre a curvatura e topologia da malha. O programa ainda permite alternar entre a visualização de superfícies do tipo Bézier e NURBS, oferecendo uma comparação direta entre os dois métodos de interpolação.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[splinesinter.c]

#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;GLUT/glut.h&gt;

// --- Variáveis Globais ---
GLint eixox = 0, eixoy = 0, eixoz = 0;
GLint nVertices = 4;
GLfloat vertices[4][4][3];
GLint largura, altura;

enum { BEZIER, NURBS };
GLint spline;

GLUnurbsObj *nc;
GLfloat nos[8] = {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};
GLint nNos = 8;

// Novas variáveis para interatividade
int selected_i = -1, selected_j = -1; // Índices do ponto de controle selecionado

// --- Funções ---

void gera_superficie(void) {
    int i, j;
    for (i = 0; i &lt; 4; i++) {
        for (j = 0; j &lt; 4; j++) {
            vertices[i][j][0] = 2.0 * ((GLfloat)i - 1.5);
            vertices[i][j][1] = 2.0 * ((GLfloat)j - 1.5);
            if ((i == 1 || i == 2) &amp;&amp; (j == 1 || j == 2))
                vertices[i][j][2] = 7.0;
            else
                vertices[i][j][2] = -3.0;
        }
    }
}

void display(void) {
    int i, j;
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glPushMatrix();
    glRotatef(eixox, 1, 0, 0);
    glRotatef(eixoy, 0, 1, 0);
    glRotatef(eixoz, 0, 0, 1);
    glScalef(0.25, 0.25, 0.25);

    // Desenha eixos coordenados (opcional)
    glDisable(GL_LIGHTING);
    glPushMatrix();
    glTranslatef(-5, -5, -5);
    glColor3f(1, 1, 1);
    glBegin(GL_LINES);
    glVertex3f(0, 0, 0); glVertex3f(1, 0, 0);
    glEnd();
    glRasterPos3f(1.5, 0, 0);
    glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_10, 'x');
    glBegin(GL_LINES);
    glVertex3f(0, 0, 0); glVertex3f(0, 1, 0);
    glEnd();
    glRasterPos3f(0, 1.5, 0);
    glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_10, 'y');
    glBegin(GL_LINES);
    glVertex3f(0, 0, 0); glVertex3f(0, 0, 1);
    glEnd();
    glRasterPos3f(0, 0, 1.5);
    glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_10, 'z');
    glPopMatrix();
    glEnable(GL_LIGHTING);


    // Desenha a superfície
    switch (spline) {
    case BEZIER:
        glMap2f(GL_MAP2_VERTEX_3, 0.0, 1.0, 3, 4, 0, 1.0, 3 * nVertices, 4, &amp;vertices[0][0][0]);
        glEnable(GL_AUTO_NORMAL);
        glMapGrid2f(20, 0.0, 1.0, 20, 0.0, 1.0);
        glEvalMesh2(GL_FILL, 0, 20, 0, 20);
        break;
    case NURBS:
        gluBeginSurface(nc);
        gluNurbsSurface(nc, nNos, nos, nNos, nos, 4 * 3, 3, &amp;vertices[0][0][0], 4, 4, GL_MAP2_VERTEX_3);
        gluEndSurface(nc);
        break;
    }

    // Desenha os pontos de controle
    glPointSize(7.0);
    glDisable(GL_LIGHTING);
    glBegin(GL_POINTS);
    for (i = 0; i &lt; 4; i++) {
        for (j = 0; j &lt; 4; j++) {
            if (i == selected_i &amp;&amp; j == selected_j) {
                glColor3f(1.0, 1.0, 0.0); // Amarelo para o ponto selecionado
            } else {
                glColor3f(1.0, 0.0, 0.0); // Vermelho para os outros
            }
            glVertex3fv(&amp;vertices[i][j][0]);
        }
    }
    glEnd();
    glEnable(GL_LIGHTING);

    glPopMatrix();
    glFlush();
    glutSwapBuffers();
}

void init(void) {
    GLfloat mat_diffuse[] = {0.7, 0.7, 0.7, 1.0};
    GLfloat mat_specular[] = {1.0, 1.0, 1.0, 1.0};
    GLfloat mat_shininess[] = {100.0};

    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);

    gera_superficie();

    nc = gluNewNurbsRenderer();
    gluNurbsProperty(nc, GLU_SAMPLING_TOLERANCE, 5.0);
    gluNurbsProperty(nc, GLU_DISPLAY_MODE, GLU_FILL);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef(0.0, 0.0, -5.0);
    spline = NURBS;
    glClearColor(0.0, 0.0, 0.0, 0.0);
    glShadeModel(GL_SMOOTH);
    glEnable(GL_MAP2_VERTEX_3);
    display();
}

void reshape(int w, int h) {
    largura = w;
    altura = h;
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45.0, (GLdouble)w / (GLdouble)h, 3.0, 8.0);
    glMatrixMode(GL_MODELVIEW);
}

void keyboard(unsigned char key, int x, int y) {
    switch (key) {
    case 'x': eixox = (eixox + 5) % 360; glutPostRedisplay(); break;
    case 'X': eixox = (eixox - 5) % 360; glutPostRedisplay(); break;
    case 'y': eixoy = (eixoy + 5) % 360; glutPostRedisplay(); break;
    case 'Y': eixoy = (eixoy - 5) % 360; glutPostRedisplay(); break;
    case 'z': eixoz = (eixoz + 5) % 360; glutPostRedisplay(); break;
    case 'Z': eixoz = (eixoz - 5) % 360; glutPostRedisplay(); break;
    case 'b': spline = BEZIER; glutPostRedisplay(); break;
    case 'n': spline = NURBS; glutPostRedisplay(); break;
    case 27: exit(0); break;
    }
}

// --- Funções de Seleção e Movimentação ---

// Função para calcular o produto escalar de dois vetores
GLfloat dot_product(GLfloat v1[3], GLfloat v2[3]) {
    return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
}

// Função para subtrair dois vetores (res = v1 - v2)
void subtract_vectors(GLfloat v1[3], GLfloat v2[3], GLfloat res[3]) {
    res[0] = v1[0] - v2[0];
    res[1] = v1[1] - v2[1];
    res[2] = v1[2] - v2[2];
}


// Função para selecionar um ponto de controle
void select_point(int x, int y) {
    GLdouble model[16], proj[16];
    GLint view[4];
    GLdouble near_pos[3], far_pos[3];

    // Obter matrizes e viewport atuais
    glGetDoublev(GL_MODELVIEW_MATRIX, model);
    glGetDoublev(GL_PROJECTION_MATRIX, proj);
    glGetIntegerv(GL_VIEWPORT, view);

    // Obter ponto no plano próximo (z=0)
    gluUnProject(x, view[3] - y, 0.0, model, proj, view, &amp;near_pos[0], &amp;near_pos[1], &amp;near_pos[2]);
    // Obter ponto no plano distante (z=1)
    gluUnProject(x, view[3] - y, 1.0, model, proj, view, &amp;far_pos[0], &amp;far_pos[1], &amp;far_pos[2]);

    // Calcular o raio
    GLfloat ray_origin[3] = {(GLfloat)near_pos[0], (GLfloat)near_pos[1], (GLfloat)near_pos[2]};
    GLfloat ray_dir[3];
    subtract_vectors((GLfloat*)far_pos, (GLfloat*)near_pos, ray_dir);

    float min_dist_sq = 1e6; // Um número grande para a distância mínima ao quadrado
    selected_i = -1;
    selected_j = -1;

    // Iterar por todos os pontos de controle para encontrar o mais próximo do raio
    for (int i = 0; i &lt; 4; i++) {
        for (int j = 0; j &lt; 4; j++) {
            GLfloat R[3] = {vertices[i][j][0], vertices[i][j][1], vertices[i][j][2]};

            // Usando a fórmula: P_o + ((R - P_o) . V) / (V . V) * V
            GLfloat R_minus_Po[3];
            subtract_vectors(R, ray_origin, R_minus_Po);

            float t = dot_product(R_minus_Po, ray_dir) / dot_product(ray_dir, ray_dir);

            // Encontrar o ponto mais próximo na linha
            GLfloat closest_point[3];
            closest_point[0] = ray_origin[0] + t * ray_dir[0];
            closest_point[1] = ray_origin[1] + t * ray_dir[1];
            closest_point[2] = ray_origin[2] + t * ray_dir[2];

            // Calcular a distância (ao quadrado) entre o ponto de controle e o ponto no raio
            GLfloat dist_vec[3];
            subtract_vectors(R, closest_point, dist_vec);
            float dist_sq = dot_product(dist_vec, dist_vec);

            if (dist_sq &lt; min_dist_sq) {
                min_dist_sq = dist_sq;
                selected_i = i;
                selected_j = j;
            }
        }
    }

    // Define um limiar para a seleção. Se o ponto mais próximo ainda estiver
    // muito longe, considera que nenhum ponto foi clicado.
    // Este valor pode precisar de ajuste.
    if (min_dist_sq &gt; 0.1) {
        selected_i = -1;
        selected_j = -1;
    }
}


// Função de callback do mouse
void mouse(int button, int state, int x, int y) {
    if (button == GLUT_LEFT_BUTTON) {
        if (state == GLUT_DOWN) {
            select_point(x, y);
        } else { // state == GLUT_UP
            selected_i = -1; // Desseleciona o ponto
            selected_j = -1;
        }
    }
    glutPostRedisplay();
}

// Função de callback de movimento do mouse (arrastar)
void motion(int x, int y) {
    if (selected_i == -1) return; // Nenhum ponto selecionado

    GLdouble model[16], proj[16];
    GLint view[4];
    GLdouble new_pos[3];
    GLdouble winZ;

    // Obter matrizes e viewport
    glGetDoublev(GL_MODELVIEW_MATRIX, model);
    glGetDoublev(GL_PROJECTION_MATRIX, proj);
    glGetIntegerv(GL_VIEWPORT, view);

    // Projeta o ponto selecionado na tela para obter sua profundidade (winZ)
    gluProject(vertices[selected_i][selected_j][0], vertices[selected_i][selected_j][1], vertices[selected_i][selected_j][2],
               model, proj, view, &amp;new_pos[0], &amp;new_pos[1], &amp;winZ);

    // "Desprojeta" a nova posição do mouse (x, y) usando a profundidade original do ponto
    // Isso move o ponto em um plano paralelo à tela
    gluUnProject(x, view[3] - y, winZ, model, proj, view, &amp;new_pos[0], &amp;new_pos[1], &amp;new_pos[2]);

    // Atualiza as coordenadas do ponto de controle
    vertices[selected_i][selected_j][0] = (GLfloat)new_pos[0];
    vertices[selected_i][selected_j][1] = (GLfloat)new_pos[1];
    vertices[selected_i][selected_j][2] = (GLfloat)new_pos[2];

    glutPostRedisplay();
}


int main(int argc, char **argv) {
    glutInit(&amp;argc, argv);
    glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGB);
    glutInitWindowSize(600, 600);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Spline Interativa");
    init();
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutKeyboardFunc(keyboard);

    // Registrar as novas callbacks de mouse
    glutMouseFunc(mouse);
    glutMotionFunc(motion);

    glutMainLoop();
    return 0;
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="8.1.png" alt="Saída do Exercício 8.1">
</div>
<div class="title">Figure 14. Exercício 8.1</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_capítulo_9">Capítulo 9</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo tem como propósito introduzir conceitos avançados de OpenGL, incluindo o uso de display lists para otimização de renderização, técnicas de mapeamento de texturas para aplicação de imagens sobre superfícies e o tratamento de teclas especiais para interação com o usuário por meio do teclado.</p>
</div>
<div class="sect2">
<h3 id="_exercício_1_8">Exercício 1</h3>
<div class="paragraph">
<p>O programa <strong>superjato.c</strong> é uma extensão do exemplo <strong>jato.c</strong>, que adiciona novos elementos visuais ao modelo original de avião a jato utilizando OpenGL. O principal objetivo da atividade foi incrementar o modelo 3D com a inclusão de uma turbina traseira e dois mísseis sob as asas, tornando a representação do avião mais detalhada e realista.</p>
</div>
<div class="paragraph">
<p>A turbina foi modelada com um cilindro (gluCylinder) posicionado na parte traseira inferior da fuselagem, simulando a saída de propulsão do jato. Já os mísseis foram adicionados sob cada asa, também com cilindros, utilizando transformações de translação e coloração para destacá-los do restante da estrutura. Além disso, o restante da estrutura do avião, como corpo, asas, cauda, nariz e cabine do piloto, foi mantido conforme o modelo original, utilizando listas de exibição (glNewList) e objetos quadráticos (GLUquadricObj) com aplicação de texturas. O código também mantém o controle de visualização 3D com movimentação da câmera via teclado (setas direcionais e teclas r, R, t) e habilita profundidade e transparência com glEnable(GL_DEPTH_TEST) e glBlendFunc(&#8230;&#8203;), garantindo uma renderização correta dos elementos sobrepostos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[superjato.c]

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;GLUT/glut.h&gt;
#include "png_texture.h"

#define PI 3.1415

#define COORD_TEXTURA_PLANO 1.0
#define COORD_TEXTURA_AVIAO 1.0
#define COR_DO_PLANO 0.52,0.52,0.78,1.0
#define COR_DO_AVIAO 0.3,0.52,0.18,1.0
#define TEXTURA_DO_PLANO "montanhas.png"
#define TEXTURA_DO_AVIAO "camuflagem.png"


GLint WIDTH =800;
GLint HEIGHT=600;

GLfloat obs[3]={0.0,7.0,0.0};
GLfloat look[3]={0.0,3.0,0.0};
GLuint  textura_plano;
GLuint  textura_aviao;

GLshort texturas=1;
GLfloat tetaxz=0;
GLfloat raioxz=6;
GLuint  jato;

GLfloat ctp[4][2]={
  {-COORD_TEXTURA_PLANO,-COORD_TEXTURA_PLANO},
  {+COORD_TEXTURA_PLANO,-COORD_TEXTURA_PLANO},
  {+COORD_TEXTURA_PLANO,+COORD_TEXTURA_PLANO},
  {-COORD_TEXTURA_PLANO,+COORD_TEXTURA_PLANO}
};

GLfloat cta[4][2]={
  {-COORD_TEXTURA_AVIAO,-COORD_TEXTURA_AVIAO},
  {+COORD_TEXTURA_AVIAO,-COORD_TEXTURA_AVIAO},
  {+COORD_TEXTURA_AVIAO,+COORD_TEXTURA_AVIAO},
  {-COORD_TEXTURA_AVIAO,+COORD_TEXTURA_AVIAO}
};

void reshape(int width, int height){
  WIDTH=width;
  HEIGHT=height;
  glViewport(0,0,(GLint)width,(GLint)height);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(70.0,width/(float)height,0.1,30.0);
  glMatrixMode(GL_MODELVIEW);
}

void compoe_jato(void){
  GLUquadricObj *quadric;

  GLfloat asa[][3]={
    {-4.0,0.0,0.0},
    {+4.0,0.0,0.0},
    {0.0,0.0,3.0}
  };

  GLfloat cauda[][3]={
    {0.0,0.0,0.0},
    {0.0,2.0,-1.0},
    {0.0,2.0,0.0},
    {0.0,0.0,2.0}
  };

  jato = glGenLists(1);
  glNewList(jato, GL_COMPILE);

  // Asas
  glBegin(GL_TRIANGLES);
  glTexCoord2fv(cta[0]); glVertex3fv(asa[0]);
  glTexCoord2fv(cta[1]); glVertex3fv(asa[1]);
  glTexCoord2fv(cta[3]); glVertex3fv(asa[2]);
  glEnd();

  // Corpo
  quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  gluCylinder(quadric, 0.5, 0.5, 4, 12, 3);

  // Nariz
  quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  glPushMatrix();
  glTranslatef(0,0,4);
  gluCylinder(quadric, 0.5, 0.0, 1.5, 12, 3);
  glPopMatrix();

  // Cauda
  glBegin(GL_POLYGON);
  glTexCoord2fv(cta[0]); glVertex3fv(cauda[0]);
  glTexCoord2fv(cta[1]); glVertex3fv(cauda[1]);
  glTexCoord2fv(cta[2]); glVertex3fv(cauda[2]);
  glTexCoord2fv(cta[3]); glVertex3fv(cauda[3]);
  glEnd();

  // Cabine do piloto
  glTranslatef(0,0.3,3.5);
  glPushMatrix();
  glScalef(0.7,0.7,2.0);
  quadric=gluNewQuadric();
  glColor4f(0.3,0.5,1,0.5);
  glDisable(GL_TEXTURE_2D);
  gluSphere(quadric,0.5,12,12);
  glEnable(GL_TEXTURE_2D);
  glPopMatrix();

  // Turbina traseira
  glPushMatrix();
  glTranslatef(0.0, -0.2, -4.0);
  glColor4f(0.0, 0.0, 0.0, 1.0);
  quadric = gluNewQuadric();
  gluCylinder(quadric, 0.4, 0.4, 1.0, 12, 3);
  glPopMatrix();

  // Míssil esquerdo
  glPushMatrix();
  glTranslatef(-2.5, -0.4, -3.0);
  glColor4f(0.8, 0.1, 0.1, 1.0);
  quadric = gluNewQuadric();
  gluCylinder(quadric, 0.1, 0.1, 1.0, 10, 3);
  glPopMatrix();

  // Míssil direito
  glPushMatrix();
  glTranslatef(2.5, -0.4, -3.0);
  glColor4f(0.8, 0.1, 0.1, 1.0);
  quadric = gluNewQuadric();
  gluCylinder(quadric, 0.1, 0.1, 1.0, 10, 3);
  glPopMatrix();

  glEndList();
}

void display(void){
  glEnable(GL_DEPTH_TEST);
  glClearColor(1.0,1.0,1.0,1.0);
  glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
  glPushMatrix();

  obs[0]=raioxz*cos(2*PI*tetaxz/360);
  obs[2]=raioxz*sin(2*PI*tetaxz/360);
  gluLookAt(obs[0],obs[1],obs[2],look[0],look[1],look[2],0.0,1.0,0.0);

  if(texturas){
    glEnable(GL_TEXTURE_2D);
  } else {
    glDisable(GL_TEXTURE_2D);
  }
  glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_DECAL);

  // Plano cheio
  glPushMatrix();
  glColor4f(COR_DO_PLANO);
  glPolygonMode( GL_FRONT_AND_BACK, GL_FILL );
  glBindTexture(GL_TEXTURE_2D,textura_plano);
  glBegin(GL_QUADS);
  glTexCoord2fv(ctp[0]);  glVertex3f(-10,0,10);
  glTexCoord2fv(ctp[1]);  glVertex3f(10,0,10);
  glTexCoord2fv(ctp[2]);  glVertex3f(10,0,-10);
  glTexCoord2fv(ctp[3]);  glVertex3f(-10,0,-10);
  glEnd();
  glTranslatef(0.0,2.0,-3.0);
  glColor4f(COR_DO_AVIAO);
  glBindTexture(GL_TEXTURE_2D,textura_aviao);
  glCallList(jato);
  glPopMatrix();

  // Malha do plano
  glPushMatrix();
  glPolygonMode( GL_FRONT_AND_BACK, GL_LINE );
  glColor4f(COR_DO_PLANO);
  glBindTexture(GL_TEXTURE_2D,textura_plano);
  glBegin(GL_QUADS);
  glTexCoord2fv(ctp[0]);  glVertex3f(-10,0,10);
  glTexCoord2fv(ctp[1]);  glVertex3f(10,0,10);
  glTexCoord2fv(ctp[2]);  glVertex3f(10,0,-10);
  glTexCoord2fv(ctp[3]);  glVertex3f(-10,0,-10);
  glEnd();
  glTranslatef(0.0,2.0,-3.0);
  glColor4f(COR_DO_AVIAO);
  glBindTexture(GL_TEXTURE_2D,textura_aviao);
  glCallList(jato);
  glPopMatrix();

  glPopMatrix();
  glutSwapBuffers();
}

void special(int key, int x, int y){
  switch (key) {
    case GLUT_KEY_UP: obs[1] += 1; break;
    case GLUT_KEY_DOWN: obs[1] -= 1; break;
    case GLUT_KEY_LEFT: tetaxz += 2; break;
    case GLUT_KEY_RIGHT: tetaxz -= 2; break;
  }
  glutPostRedisplay();
}

void keyboard(unsigned char key, int x, int y){
  switch (key) {
    case 27: exit(0); break;
    case 't': texturas = !texturas; break;
    case 'r': raioxz += 1; break;
    case 'R': raioxz = (raioxz == 1) ? 1 : raioxz - 1; break;
  }
  glutPostRedisplay();
}

void carregar_texturas(void){
  textura_plano = png_texture_load(TEXTURA_DO_PLANO, NULL, NULL);
  textura_aviao = png_texture_load(TEXTURA_DO_AVIAO, NULL, NULL);
}

void init(){
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  carregar_texturas();
  compoe_jato();
  glEnable(GL_TEXTURE_2D);
}

int main(int argc,char **argv){
  glutInitWindowPosition(0,0);
  glutInitWindowSize(WIDTH,HEIGHT);
  glutInit(&amp;argc,argv);
  glutInitDisplayMode(GLUT_RGBA|GLUT_DEPTH|GLUT_DOUBLE|GLUT_ALPHA);

  if(!glutCreateWindow("Super Jato")) {
    fprintf(stderr,"Error opening a window.\n");
    exit(-1);
  }

  init();
  glutKeyboardFunc(keyboard);
  glutSpecialFunc(special);
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutMainLoop();

  return(0);
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="9.1.png" alt="Saída do Exercício 9.1">
</div>
<div class="title">Figure 15. Exercício 9.1</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_capítulo_10">Capítulo 10</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este capítulo tem como objetivo ilustrar os principais conceitos envolvidos na iluminação de uma cena gráfica e na definição das propriedades ópticas dos materiais, como refletância, brilho e transparência.</p>
</div>
<div class="sect2">
<h3 id="_exercício_1_9">Exercício 1</h3>
<div class="paragraph">
<p>O programa <strong>iluminacao2.c</strong> foi desenvolvido a partir do código base <strong>iluminacao.c</strong>, com a adição de interatividade por meio do uso do mouse. A principal proposta da atividade era permitir que o usuário modificasse a transparência do objeto B ao mover o mouse horizontal ou verticalmente, desde que nenhuma tecla estivesse pressionada. Além disso, caso a tecla SHIFT estivesse ativa durante o movimento do mouse, o programa deveria ajustar os níveis de iluminação ambiente da luz principal da cena.</p>
</div>
<div class="paragraph">
<p>Para atender a esses requisitos, foram implementadas duas novas funções: motion() e mouse(). A função mouse() identifica quando o botão do mouse é pressionado ou liberado e verifica se a tecla SHIFT está sendo segurada. Já a função motion() calcula o deslocamento do mouse em relação à posição anterior e, com base nisso, modifica o valor da transparência (canal alfa) do material do objeto B, ou altera a intensidade da luz ambiente, dependendo do estado da tecla SHIFT. Para garantir que os valores de transparência e de iluminação não ultrapassem os limites permitidos pelo OpenGL, foi criada uma função auxiliar chamada clamp() que restringe os valores ao intervalo entre 0.0 e 1.0. As demais funcionalidades do código original foram mantidas, incluindo a configuração de materiais, a criação das fontes de luz, o desenho dos objetos e o controle de visualização da cena com as teclas do teclado. No main(), além das funções já existentes, foram adicionadas as chamadas glutMotionFunc() e glutMouseFunc() para ativar o controle por mouse.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>[iluminacao2.c]
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;GLUT/glut.h&gt;

#define PI 3.1415

GLint WIDTH = 320;
GLint HEIGHT = 240;

GLint fatias = 30;
GLint pilhas = 30;
GLint raioEsfera = 1.5;

GLfloat obs[3] = {0.0, 7.0, 0.0};
GLfloat olho[3] = {0.0, 3.0, 0.0};

GLfloat plano_difusa[] = {0.5, 0.5, 0.0, 1.0};
GLfloat plano_especular[] = {1.0, 1.0, 1.0, 1.0};
GLfloat plano_brilho[] = {50.0};

GLfloat mat_a_difusa[] = {1.0, 1.0, 1.0, 1.0};
GLfloat mat_a_especular[] = {1.0, 1.0, 1.0, 1.0};
GLfloat mat_a_brilho[] = {50.0};

GLfloat mat_b_difusa[] = {0.7, 0.7, 0.7, 0.5};
GLfloat mat_b_especular[] = {1.0, 1.0, 1.0, 0.5};
GLfloat mat_b_brilho[] = {50.0};

GLfloat posicao_luz0[] = {0.0, 10.0, 0.0, 1.0};
GLfloat cor_luz0[] = {1.0, 1.0, 1.0, 1.0};
GLfloat cor_luz0_amb[] = {0.3, 0.3, 0.3, 1.0};

GLfloat posicao_luz1[] = {0.0, 10.0, 5.0, 1.0};
GLfloat cor_luz1[] = {0.0, 0.0, 1.0, 1.0};
GLfloat direcao_luz1[] = {0.0, -10.0, -5.0, 1.0};
GLint spot_luz1 = 30;

GLfloat sem_cor[] = {0.0, 0.0, 0.0, 1.0};

GLint gouraud = 0;

GLfloat tetaxz = 0;
GLfloat raioxz = 6;

// Mouse state
int lastX = -1, lastY = -1;
int shiftPressed = 0;

void clamp(GLfloat *value) {
  if (*value &lt; 0.0f) *value = 0.0f;
  if (*value &gt; 1.0f) *value = 1.0f;
}

void motion(int x, int y) {
  if (lastX &lt; 0 || lastY &lt; 0) {
    lastX = x;
    lastY = y;
    return;
  }

  int dx = x - lastX;
  int dy = y - lastY;

  if (shiftPressed) {
    // Modificar iluminação ambiente
    for (int i = 0; i &lt; 3; i++) {
      cor_luz0_amb[i] += (dx - dy) * 0.005f;
      clamp(&amp;cor_luz0_amb[i]);
    }
    glLightfv(GL_LIGHT0, GL_AMBIENT, cor_luz0_amb);
  } else {
    // Modificar transparência (alpha) do objeto B
    mat_b_difusa[3] += (dx - dy) * 0.005f;
    mat_b_especular[3] = mat_b_difusa[3];
    clamp(&amp;mat_b_difusa[3]);
    clamp(&amp;mat_b_especular[3]);
  }

  lastX = x;
  lastY = y;
  glutPostRedisplay();
}

void mouse(int button, int state, int x, int y) {
  if (state == GLUT_DOWN) {
    lastX = x;
    lastY = y;
    shiftPressed = (glutGetModifiers() &amp; GLUT_ACTIVE_SHIFT);
  } else if (state == GLUT_UP) {
    lastX = -1;
    lastY = -1;
  }
}

void reshape(int width, int height) {
  WIDTH = width;
  HEIGHT = height;
  glViewport(0, 0, (GLint)width, (GLint)height);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(70.0, width / (float)height, 0.1, 30.0);
  glMatrixMode(GL_MODELVIEW);
}

void display(void) {
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_LIGHTING);

  glDepthMask(GL_TRUE);
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  glShadeModel(gouraud ? GL_SMOOTH : GL_FLAT);

  glPushMatrix();

  obs[0] = raioxz * cos(2 * PI * tetaxz / 360);
  obs[2] = raioxz * sin(2 * PI * tetaxz / 360);
  gluLookAt(obs[0], obs[1], obs[2], olho[0], olho[1], olho[2], 0.0, 1.0, 0.0);

  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, plano_difusa);
  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, plano_especular);
  glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, plano_brilho);

  glNormal3f(0, 1, 0);
  glBegin(GL_QUADS);
  glVertex3f(-10, 0, 10);
  glVertex3f(10, 0, 10);
  glVertex3f(10, 0, -10);
  glVertex3f(-10, 0, -10);
  glEnd();

  glPushMatrix();
  glTranslatef(posicao_luz0[0], posicao_luz0[1], posicao_luz0[2]);
  glColor3f(1, 0, 0);
  glMaterialfv(GL_FRONT, GL_EMISSION, cor_luz0);
  glutSolidSphere(0.3, 5, 5);
  glPopMatrix();

  glPushMatrix();
  glTranslatef(posicao_luz1[0], posicao_luz1[1], posicao_luz1[2]);
  glMaterialfv(GL_FRONT, GL_EMISSION, cor_luz1);
  glutSolidSphere(0.3, 5, 5);
  glPopMatrix();

  glMaterialfv(GL_FRONT, GL_EMISSION, sem_cor);

  glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_a_difusa);
  glMaterialfv(GL_FRONT, GL_SPECULAR, mat_a_especular);
  glMaterialfv(GL_FRONT, GL_SHININESS, mat_a_brilho);

  glPushMatrix();
  glTranslatef(0.0, 3.0, -3.0);
  glutSolidSphere(raioEsfera, fatias, pilhas);
  glPopMatrix();

  glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_b_difusa);
  glMaterialfv(GL_FRONT, GL_SPECULAR, mat_b_especular);
  glMaterialfv(GL_FRONT, GL_SHININESS, mat_b_brilho);

  glTranslatef(0.0, 3.0, 3.0);
  glutSolidSphere(raioEsfera, fatias, pilhas);

  glPopMatrix();
  glutSwapBuffers();
}

void special(int key, int x, int y) {
  switch (key) {
    case GLUT_KEY_UP: obs[1] += 1; break;
    case GLUT_KEY_DOWN: obs[1] -= 1; break;
    case GLUT_KEY_LEFT: tetaxz += 2; break;
    case GLUT_KEY_RIGHT: tetaxz -= 2; break;
  }
  glutPostRedisplay();
}

void keyboard(unsigned char key, int x, int y) {
  switch (key) {
    case 27: exit(0); break;
    case 'g': gouraud = !gouraud; break;
    case 'r': raioxz += 1; break;
    case 'R': if (raioxz &gt; 1) raioxz -= 1; break;
  }
  glutPostRedisplay();
}

void init() {
  gouraud = 1;
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

  glLightfv(GL_LIGHT0, GL_DIFFUSE, cor_luz0);
  glLightfv(GL_LIGHT0, GL_SPECULAR, cor_luz0);
  glLightfv(GL_LIGHT0, GL_AMBIENT, cor_luz0_amb);
  glLightfv(GL_LIGHT0, GL_POSITION, posicao_luz0);

  glLightfv(GL_LIGHT1, GL_DIFFUSE, cor_luz1);
  glLightfv(GL_LIGHT1, GL_SPECULAR, cor_luz1);
  glLightf(GL_LIGHT1, GL_SPOT_CUTOFF, spot_luz1);
  glLightfv(GL_LIGHT1, GL_POSITION, posicao_luz1);
  glLightfv(GL_LIGHT1, GL_SPOT_DIRECTION, direcao_luz1);

  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_LIGHT1);

  glEnable(GL_AUTO_NORMAL);
  glEnable(GL_NORMALIZE);
}

void menu(int value) {
  switch (value) {
    case 0: mat_a_especular[0] = mat_a_especular[1] = mat_a_especular[2] = 0.0; break;
    case 1: mat_a_especular[0] = mat_a_especular[1] = mat_a_especular[2] = 0.5; break;
    case 2: mat_a_especular[0] = mat_a_especular[1] = mat_a_especular[2] = 1.0; break;
    case 3: mat_a_difusa[0] = mat_a_difusa[1] = mat_a_difusa[2] = 0.0; break;
    case 4: mat_a_difusa[0] = mat_a_difusa[1] = mat_a_difusa[2] = 0.5; break;
    case 5: mat_a_difusa[0] = mat_a_difusa[1] = mat_a_difusa[2] = 1.0; break;
  }
  glutPostRedisplay();
}

int main(int argc, char **argv) {
  glutInitWindowPosition(0, 0);
  glutInitWindowSize(WIDTH, HEIGHT);
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_RGB | GLUT_DEPTH | GLUT_DOUBLE);

  if (!glutCreateWindow("Iluminacao com Transparência e Mouse")) {
    fprintf(stderr, "Erro ao criar janela.\n");
    exit(-1);
  }

  init();

  glutKeyboardFunc(keyboard);
  glutSpecialFunc(special);
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutMotionFunc(motion);
  glutMouseFunc(mouse);

  glutCreateMenu(menu);
  glutAddMenuEntry("-sem spec", 0);
  glutAddMenuEntry("-spec media", 1);
  glutAddMenuEntry("-spec alta", 2);
  glutAddMenuEntry("-sem difusa", 3);
  glutAddMenuEntry("-difusa media", 4);
  glutAddMenuEntry("-difusa alta", 5);
  glutAttachMenu(GLUT_RIGHT_BUTTON);

  glutMainLoop();
  return 0;
}</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="10.1.gif" alt="Saída do Exercício 10.1">
</div>
<div class="title">Figure 16. Exercício 10.1</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-07-15 12:16:55 -0300
</div>
</div>
</body>
</html>